   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  07/02/18             */
   /*                                                     */
   /*          DEFRULE BASIC COMMANDS HEADER FILE         */
   /*******************************************************/

/*************************************************************/
/* Purpose: Implements core commands for the defrule         */
/*   construct such as clear, reset, save, undefrule,        */
/*   ppdefrule, list-defrules, and                           */
/*   get-defrule-list.                                       */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable log to logName        */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Removed conditional code for unsupported       */
/*            compilers/operating systems (IBM_MCW,          */
/*            MAC_MCW, and IBM_TBC).                         */
/*                                                           */
/*            Support for join network changes.              */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*            Added code to prevent a clear command from     */
/*            being executed during fact assertions via      */
/*            JoinOperationInProgress mechanism.             */
/*                                                           */
/*      6.40: Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*            Pretty print functions accept optional logical */
/*            name argument.                                 */
/*                                                           */
/*************************************************************/

#include "setup.h"

#if DEFRULE_CONSTRUCT

#include <stdio.h>

#include "argacces.h"
#include "constrct.h"
#include "drive.h"
#include "engine.h"
#include "envrnmnt.h"
#include "extnfunc.h"
#include "multifld.h"
#include "reteutil.h"
#include "router.h"
#include "ruledef.h"
#include "watch.h"

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
#include "rulebin.h"
#endif
#if CONSTRUCT_COMPILER && (! RUN_TIME)
#include "rulecmp.h"
#endif

#include "rulebsc.h"

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

   static void                    CL_ResetDefrules(Environment *,void *);
   static void                    CL_ResetDefrulesPrime(Environment *,void *);
   static void                    CL_SaveDefrules(Environment *,Defmodule *,const char *,void *);
#if (! RUN_TIME)
   static bool                    CL_ClearDefrulesReady(Environment *,void *);
   static void                    CL_ClearDefrules(Environment *,void *);
#endif

/*************************************************************/
/* CL_DefruleBasicCommands: Initializes basic defrule commands. */
/*************************************************************/
void CL_DefruleBasicCommands(
  Environment *theEnv)
  {
   CL_Add_ResetFunction(theEnv,"defrule",CL_ResetDefrules,70,NULL);
   CL_Add_ResetFunction(theEnv,"defrule",CL_ResetDefrulesPrime,10,NULL);
   CL_Add_SaveFunction(theEnv,"defrule",CL_SaveDefrules,0,NULL);
#if (! RUN_TIME)
   CL_Add_ClearReadyFunction(theEnv,"defrule",CL_ClearDefrulesReady,0,NULL);
   CL_Add_ClearFunction(theEnv,"defrule",CL_ClearDefrules,0,NULL);
#endif

#if DEBUGGING_FUNCTIONS
   CL_Add_WatchItem(theEnv,"rules",0,&DefruleData(theEnv)->CL_WatchRules,70,CL_Defrule_WatchAccess,CL_Defrule_WatchPrint);
#endif

#if ! RUN_TIME
   CL_AddUDF(theEnv,"get-defrule-list","m",0,1,"y",CL_GetDefruleListFunction,"CL_GetDefruleListFunction",NULL);
   CL_AddUDF(theEnv,"undefrule","v",1,1,"y",CL_UndefruleCommand,"CL_UndefruleCommand",NULL);
   CL_AddUDF(theEnv,"defrule-module","y",1,1,"y",CL_DefruleModuleFunction,"CL_DefruleModuleFunction",NULL);

#if DEBUGGING_FUNCTIONS
   CL_AddUDF(theEnv,"rules","v",0,1,"y",CL_ListDefrulesCommand,"CL_ListDefrulesCommand",NULL);
   CL_AddUDF(theEnv,"list-defrules","v",0,1,"y",CL_ListDefrulesCommand,"CL_ListDefrulesCommand",NULL);
   CL_AddUDF(theEnv,"ppdefrule","vs",1,2,";y;ldsyn",CL_PPDefruleCommand,"CL_PPDefruleCommand",NULL);
#endif

#if (BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE)
   CL_DefruleBinarySetup(theEnv);
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
   CL_DefruleCompilerSetup(theEnv);
#endif

#endif
  }

/*****************************************************/
/* CL_ResetDefrules: Defrule reset routine for use with */
/*   the reset command. Sets the current entity time */
/*   tag (used by the conflict resolution strategies */
/*   for recency) to zero. The focus stack is also   */
/*   cleared.                                        */
/*****************************************************/
static void CL_ResetDefrules(
  Environment *theEnv,
  void *context)
  {
   Defmodule *theModule;
   struct joinLink *theLink;
   struct partialMatch *notParent;

   DefruleData(theEnv)->CurrentEntityTimeTag = 1L;
   CL_Clear_FocusStack(theEnv);
   theModule = CL_FindDefmodule(theEnv,"MAIN");
   CL_Focus(theModule);

   for (theLink = DefruleData(theEnv)->RightPrimeJoins;
        theLink != NULL;
        theLink = theLink->next)
     { CL_PosEntry_RetractAlpha(theEnv,theLink->join->rightMemory->beta[0],NETWORK_ASSERT); }

   for (theLink = DefruleData(theEnv)->LeftPrimeJoins;
        theLink != NULL;
        theLink = theLink->next)
     {
      if ((theLink->join->patternIsNegated || theLink->join->joinFromTheRight) &&
          (! theLink->join->patternIsExists))
        {
         notParent = theLink->join->leftMemory->beta[0];

         if (notParent->marker)
           { CL_RemoveBlockedLink(notParent); }

         /*==========================================================*/
         /* Prevent any retractions from generating partial matches. */
         /*==========================================================*/

         notParent->marker = notParent;

         if (notParent->children != NULL)
           { CL_PosEntry_RetractBeta(theEnv,notParent,notParent->children,NETWORK_ASSERT); }
           /*
         if (notParent->dependents != NULL)
           { CL_RemoveLogicalSupport(theEnv,notParent); } */
        }
     }
  }

/***********************/
/* CL_ResetDefrulesPrime: */
/***********************/
static void CL_ResetDefrulesPrime(
  Environment *theEnv,
  void *context)
  {
   struct joinLink *theLink;
   struct partialMatch *notParent;

   for (theLink = DefruleData(theEnv)->RightPrimeJoins;
        theLink != NULL;
        theLink = theLink->next)
     { Network_Assert(theEnv,theLink->join->rightMemory->beta[0],theLink->join); }

   for (theLink = DefruleData(theEnv)->LeftPrimeJoins;
        theLink != NULL;
        theLink = theLink->next)
     {
      if ((theLink->join->patternIsNegated || theLink->join->joinFromTheRight) &&
          (! theLink->join->patternIsExists))
        {
         notParent = theLink->join->leftMemory->beta[0];

         if (theLink->join->secondaryNetworkTest != NULL)
           {
            if (CL_EvaluateSecondaryNetworkTest(theEnv,notParent,theLink->join) == false)
              { continue; }
           }

         notParent->marker = NULL;

         CL_EPMDrive(theEnv,notParent,theLink->join,NETWORK_ASSERT);
        }
     }

  }

#if (! RUN_TIME)

/******************************************************************/
/* CL_ClearDefrulesReady: Indicates whether defrules can be cleared. */
/******************************************************************/
static bool CL_ClearDefrulesReady(
  Environment *theEnv,
  void *context)
  {
   if (EngineData(theEnv)->ExecutingRule != NULL) return false;

   if (EngineData(theEnv)->JoinOperationInProgress) return false;

   CL_Clear_FocusStack(theEnv);
   if (CL_GetCurrentModule(theEnv) == NULL) return false;

   DefruleData(theEnv)->CurrentEntityTimeTag = 1L;

   return true;
  }

/***************************************************************/
/* CL_ClearDefrules: Pushes the MAIN module as the current focus. */
/***************************************************************/
static void CL_ClearDefrules(
  Environment *theEnv,
  void *context)
  {
   Defmodule *theModule;

   theModule = CL_FindDefmodule(theEnv,"MAIN");
   CL_Focus(theModule);
  }

#endif

/**************************************/
/* CL_SaveDefrules: Defrule save routine */
/*   for use with the save command.   */
/**************************************/
static void CL_SaveDefrules(
  Environment *theEnv,
  Defmodule *theModule,
  const char *logicalName,
  void *context)
  {
   CL_SaveConstruct(theEnv,theModule,logicalName,DefruleData(theEnv)->DefruleConstruct);
  }

/******************************************/
/* CL_UndefruleCommand: H/L access routine   */
/*   for the undefrule command.           */
/******************************************/
void CL_UndefruleCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_UndefconstructCommand(context,"undefrule",DefruleData(theEnv)->DefruleConstruct);
  }

/********************************/
/* CL_Undefrule: C access routine  */
/*   for the undefrule command. */
/********************************/
bool CL_Undefrule(
  Defrule *theDefrule,
  Environment *allEnv)
  {
   Environment *theEnv;
   
   if (theDefrule == NULL)
     {
      theEnv = allEnv;
      return CL_Undefconstruct(theEnv,NULL,DefruleData(theEnv)->DefruleConstruct);
     }
   else
     {
      theEnv = theDefrule->header.env;
      return CL_Undefconstruct(theEnv,&theDefrule->header,DefruleData(theEnv)->DefruleConstruct);
     }
  }

/************************************************/
/* CL_GetDefruleListFunction: H/L access routine   */
/*   for the get-defrule-list function.         */
/************************************************/
void CL_GetDefruleListFunction(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_GetConstructListFunction(context,returnValue,DefruleData(theEnv)->DefruleConstruct);
  }

/****************************************/
/* CL_GetDefruleList: C access routine     */
/*   for the get-defrule-list function. */
/****************************************/
void CL_GetDefruleList(
  Environment *theEnv,
  CLIPSValue *returnValue,
  Defmodule *theModule)
  {
   UDFValue result;
   
   CL_GetConstructList(theEnv,&result,DefruleData(theEnv)->DefruleConstruct,theModule);
   CL_No_rmalizeMultifield(theEnv,&result);
   returnValue->value = result.value;
  }

/*********************************************/
/* CL_DefruleModuleFunction: H/L access routine */
/*   for the defrule-module function.        */
/*********************************************/
void CL_DefruleModuleFunction(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   returnValue->value = CL_GetConstructModuleCommand(context,"defrule-module",DefruleData(theEnv)->DefruleConstruct);
  }

#if DEBUGGING_FUNCTIONS

/******************************************/
/* CL_PPDefruleCommand: H/L access routine   */
/*   for the ppdefrule command.           */
/******************************************/
void CL_PPDefruleCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_PPConstructCommand(context,"ppdefrule",DefruleData(theEnv)->DefruleConstruct,returnValue);
  }

/***********************************/
/* CL_PPDefrule: C access routine for */
/*   the ppdefrule command.        */
/***********************************/
bool CL_PPDefrule(
  Environment *theEnv,
  const char *defruleName,
  const char *logicalName)
  {
   return(CL_PPConstruct(theEnv,defruleName,logicalName,DefruleData(theEnv)->DefruleConstruct));
  }

/*********************************************/
/* CL_ListDefrulesCommand: H/L access routine   */
/*   for the list-defrules command.          */
/*********************************************/
void CL_ListDefrulesCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_ListConstructCommand(context,DefruleData(theEnv)->DefruleConstruct);
  }

/************************************/
/* CL_ListDefrules: C access routine   */
/*   for the list-defrules command. */
/************************************/
void CL_ListDefrules(
  Environment *theEnv,
  const char *logicalName,
  Defmodule *theModule)
  {
   CL_ListConstruct(theEnv,DefruleData(theEnv)->DefruleConstruct,logicalName,theModule);
  }

/*******************************************************/
/* CL_DefruleGet_WatchActivations: C access routine for    */
/*   retrieving the current watch value of a defrule's */
/*   activations.                                      */
/*******************************************************/
bool CL_DefruleGet_WatchActivations(
  Defrule *rulePtr)
  {
   Defrule *thePtr;

   for (thePtr = rulePtr;
        thePtr != NULL;
        thePtr = thePtr->disjunct)
     { if (thePtr->watchActivation) return true; }

   return false;
  }

/********************************************/
/* CL_DefruleGet_WatchFirings: C access routine */
/*   for retrieving the current watch value */
/*   of a defrule's firings.                */
/********************************************/
bool CL_DefruleGet_WatchFirings(
  Defrule *rulePtr)
  {
   Defrule *thePtr;

   for (thePtr = rulePtr;
        thePtr != NULL;
        thePtr = thePtr->disjunct)
     { if (thePtr->watchFiring) return true; }

   return false;
  }

/************************************************/
/* CL_DefruleSet_WatchActivations: C access routine */
/*   for setting the current watch value of a   */
/*   defrule's activations.                     */
/************************************************/
void CL_DefruleSet_WatchActivations(
  Defrule *rulePtr,
  bool newState)
  {
   Defrule *thePtr;

   for (thePtr = rulePtr;
        thePtr != NULL;
        thePtr = thePtr->disjunct)
     { thePtr->watchActivation = newState; }
  }

/********************************************/
/* CL_DefruleSet_WatchFirings: C access routine */
/*   for setting the current watch value of */
/*   a defrule's firings.                   */
/********************************************/
void CL_DefruleSet_WatchFirings(
  Defrule *rulePtr,
  bool newState)
  {
   Defrule *thePtr;

   for (thePtr = rulePtr;
        thePtr != NULL;
        thePtr = thePtr->disjunct)
     { thePtr->watchFiring = newState; }
  }

/*******************************************************************/
/* CL_Defrule_WatchAccess: Access function for setting the watch flags */
/*   associated with rules (activations and rule firings).         */
/*******************************************************************/
bool CL_Defrule_WatchAccess(
  Environment *theEnv,
  int code,
  bool newState,
  struct expr *argExprs)
  {
   if (code)
     return(CL_ConstructSet_WatchAccess(theEnv,DefruleData(theEnv)->DefruleConstruct,newState,argExprs,
                                    (ConstructGet_WatchFunction *) CL_DefruleGet_WatchActivations,
                                    (ConstructSet_WatchFunction *) CL_DefruleSet_WatchActivations));
   else
     return(CL_ConstructSet_WatchAccess(theEnv,DefruleData(theEnv)->DefruleConstruct,newState,argExprs,
                                    (ConstructGet_WatchFunction *) CL_DefruleGet_WatchFirings,
                                    (ConstructSet_WatchFunction *) CL_DefruleSet_WatchFirings));
  }

/*****************************************************************/
/* CL_Defrule_WatchPrint: Access routine for printing which defrules */
/*   have their watch flag set via the list-watch-items command. */
/*****************************************************************/
bool CL_Defrule_WatchPrint(
  Environment *theEnv,
  const char *logName,
  int code,
  struct expr *argExprs)
  {
   if (code)
     return(CL_ConstructPrint_WatchAccess(theEnv,DefruleData(theEnv)->DefruleConstruct,logName,argExprs,
                                      (ConstructGet_WatchFunction *) CL_DefruleGet_WatchActivations,
                                      (ConstructSet_WatchFunction *) CL_DefruleSet_WatchActivations));
   else
     return(CL_ConstructPrint_WatchAccess(theEnv,DefruleData(theEnv)->DefruleConstruct,logName,argExprs,
                                      (ConstructGet_WatchFunction *) CL_DefruleGet_WatchActivations,
                                      (ConstructSet_WatchFunction *) CL_DefruleGet_WatchActivations));
  }

#endif /* DEBUGGING_FUNCTIONS */

#endif /* DEFTEMPLATE_CONSTRUCT */
