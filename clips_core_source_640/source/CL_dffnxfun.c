   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  07/02/18             */
   /*                                                     */
   /*                 DEFFUNCTION MODULE                  */
   /*******************************************************/

/*************************************************************/
/* Purpose:                                                  */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Gary D. Riley                                        */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable log to logName        */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*            Corrected code to remove run-time program      */
/*            compiler warning.                              */
/*                                                           */
/*      6.30: Removed conditional code for unsupported       */
/*            compilers/operating systems (IBM_MCW,          */
/*            MAC_MCW, and IBM_TBC).                         */
/*                                                           */
/*            Changed integer type/precision.                */
/*                                                           */
/*            Added missing initializer for ENTITY_RECORD.   */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*            Changed find construct functionality so that   */
/*            imported modules are search when locating a    */
/*            named construct.                               */
/*                                                           */
/*            Added code to keep track of pointers to        */
/*            constructs that are contained externally to    */
/*            to constructs, DanglingConstructs.             */
/*                                                           */
/*      6.40: Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*            Pretty print functions accept optional logical */
/*            name argument.                                 */
/*                                                           */
/*************************************************************/

/* =========================================
   *****************************************
               EXTERNAL DEFINITIONS
   =========================================
   ***************************************** */
#include "setup.h"

#if DEFFUNCTION_CONSTRUCT

#if (BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE)
#include "bload.h"
#include "dffnxbin.h"
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
#include "dffnxcmp.h"
#endif

#if (! BLOAD_ONLY) && (! RUN_TIME)
#include "constrct.h"
#include "cstrcpsr.h"
#include "dffnxpsr.h"
#include "modulpsr.h"
#endif

#include "envrnmnt.h"

#if (! RUN_TIME)
#include "extnfunc.h"
#endif

#include "dffnxexe.h"

#if DEBUGGING_FUNCTIONS
#include "watch.h"
#endif

#include "argacces.h"
#include "cstrccom.h"
#include "memalloc.h"
#include "modulutl.h"
#include "multifld.h"
#include "prntutil.h"
#include "router.h"

#include "dffnxfun.h"

/* =========================================
   *****************************************
      INTERNALLY VISIBLE FUNCTION HEADERS
   =========================================
   ***************************************** */

   static void                    PrintDeffunctionCall(Environment *,const char *,Deffunction *);
   static bool                    CL_EvaluateDeffunctionCall(Environment *,Deffunction *,UDFValue *);
   static void                    DecrementDeffunctionBusyCount(Environment *,Deffunction *);
   static void                    IncrementDeffunctionBusyCount(Environment *,Deffunction *);
   static void                    DeallocateDeffunctionData(Environment *);

#if ! RUN_TIME
   static void                    DestroyDeffunctionAction(Environment *,ConstructHeader *,void *);
   static void                   *AllocateModule(Environment *);
   static void                    ReturnModule(Environment *,void *);
   static bool                    CL_ClearDeffunctionsReady(Environment *,void *);
#else
   static void                    CL_RuntimeDeffunctionAction(Environment *,ConstructHeader *,void *);
#endif

#if (! BLOAD_ONLY) && (! RUN_TIME)
   static bool                    RemoveAllDeffunctions(Environment *);
   static void                    DeffunctionDeleteError(Environment *,const char *);
   static void                    CL_SaveDeffunctionHeaders(Environment *,Defmodule *,const char *,void *);
   static void                    CL_SaveDeffunctionHeader(Environment *,ConstructHeader *,void *);
   static void                    CL_SaveDeffunctions(Environment *,Defmodule *,const char *,void *);
#endif

#if DEBUGGING_FUNCTIONS
   static bool                    DeffunctionCL_WatchAccess(Environment *,int,bool,Expression *);
   static bool                    DeffunctionCL_WatchPrint(Environment *,const char *,int,Expression *);
#endif

/* =========================================
   *****************************************
          EXTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***************************************************
  NAME         : CL_SetupDeffunctions
  DESCRIPTION  : Initializes parsers and access
                 functions for deffunctions
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Deffunction environment initialized
  NOTES        : None
 ***************************************************/
void CL_SetupDeffunctions(
  Environment *theEnv)
  {
   EntityRecord deffunctionEntityRecord =
                     { "PCALL", PCALL,0,0,1,
                       (EntityCL_PrintFunction *) PrintDeffunctionCall,
                       (EntityCL_PrintFunction *) PrintDeffunctionCall,
                       NULL,
                       (EntityCL_EvaluationFunction *) CL_EvaluateDeffunctionCall,
                       NULL,
                       (EntityBusyCountFunction *) DecrementDeffunctionBusyCount,
                       (EntityBusyCountFunction *) IncrementDeffunctionBusyCount,
                       NULL,NULL,NULL,NULL,NULL };

   CL_AllocateEnvironmentData(theEnv,DEFFUNCTION_DATA,sizeof(struct deffunctionData),DeallocateDeffunctionData);
   memcpy(&DeffunctionData(theEnv)->DeffunctionEntityRecord,&deffunctionEntityRecord,sizeof(struct entityRecord));

   CL_InstallPrimitive(theEnv,&DeffunctionData(theEnv)->DeffunctionEntityRecord,PCALL);

   DeffunctionData(theEnv)->CL_DeffunctionModuleIndex =
                CL_RegisterModuleItem(theEnv,"deffunction",
#if (! RUN_TIME)
                                    AllocateModule,
                                    ReturnModule,
#else
                                    NULL,NULL,
#endif
#if BLOAD_AND_BSAVE || BLOAD || BLOAD_ONLY
                                    CL_BloadCL_DeffunctionModuleReference,
#else
                                    NULL,
#endif
#if CONSTRUCT_COMPILER && (! RUN_TIME)
                                    CL_DeffunctionCModuleReference,
#else
                                    NULL,
#endif
                                    (CL_FindConstructFunction *) CL_FindDeffunctionInModule);
   DeffunctionData(theEnv)->DeffunctionConstruct = CL_AddConstruct(theEnv,"deffunction","deffunctions",
#if (! BLOAD_ONLY) && (! RUN_TIME)
                                       CL_ParseDeffunction,
#else
                                       NULL,
#endif
                                       (CL_FindConstructFunction *) CL_FindDeffunction,
                                       CL_GetConstructNamePointer,CL_GetConstructPPFoCL_rm,
                                       CL_GetConstructModuleItem,
                                       (GetNextConstructFunction *) CL_GetNextDeffunction,
                                       CL_SetNextConstruct,
                                       (IsConstructDeletableFunction *) CL_DeffunctionIsDeletable,
                                       (DeleteConstructFunction *) CL_Undeffunction,
#if (! BLOAD_ONLY) && (! RUN_TIME)
                                       (FreeConstructFunction *) CL_RemoveDeffunction
#else
                                       NULL
#endif
                                       );

#if ! RUN_TIME
   CL_AddCL_ClearReadyFunction(theEnv,"deffunction",CL_ClearDeffunctionsReady,0,NULL);

#if ! BLOAD_ONLY
#if DEFMODULE_CONSTRUCT
   CL_AddPortConstructItem(theEnv,"deffunction",SYMBOL_TOKEN);
#endif
   CL_AddCL_SaveFunction(theEnv,"deffunction-headers",CL_SaveDeffunctionHeaders,1000,NULL);
   CL_AddCL_SaveFunction(theEnv,"deffunctions",CL_SaveDeffunctions,0,NULL);
   CL_AddUDF(theEnv,"undeffunction","v",1,1,"y",CL_UndeffunctionCommand,"CL_UndeffunctionCommand",NULL);
#endif

#if DEBUGGING_FUNCTIONS
   CL_AddUDF(theEnv,"list-deffunctions","v",0,1,"y",CL_ListDeffunctionsCommand,"CL_ListDeffunctionsCommand",NULL);
   CL_AddUDF(theEnv,"ppdeffunction","vs",1,2,";y;ldsyn",CL_PPDeffunctionCommand,"CL_PPDeffunctionCommand",NULL);
#endif

   CL_AddUDF(theEnv,"get-deffunction-list","m",0,1,"y",CL_GetDeffunctionListFunction,"CL_GetDeffunctionListFunction",NULL);
   CL_AddUDF(theEnv,"deffunction-module","y",1,1,"y",GetCL_DeffunctionModuleCommand,"GetCL_DeffunctionModuleCommand",NULL);

#if BLOAD_AND_BSAVE || BLOAD || BLOAD_ONLY
   CL_SetupDeffunctionsCL_Bload(theEnv);
#endif

#if CONSTRUCT_COMPILER
   CL_SetupDeffunctionCompiler(theEnv);
#endif

#endif

#if DEBUGGING_FUNCTIONS
   CL_AddCL_WatchItem(theEnv,"deffunctions",0,&DeffunctionData(theEnv)->CL_WatchDeffunctions,32,
                DeffunctionCL_WatchAccess,DeffunctionCL_WatchPrint);
#endif

  }

/******************************************************/
/* DeallocateDeffunctionData: Deallocates environment */
/*    data for the deffunction construct.             */
/******************************************************/
static void DeallocateDeffunctionData(
  Environment *theEnv)
  {
#if ! RUN_TIME
   CL_DeffunctionModuleData *theModuleItem;
   Defmodule *theModule;

#if BLOAD || BLOAD_AND_BSAVE
   if (CL_Bloaded(theEnv)) return;
#endif

   CL_DoForAllConstructs(theEnv,
                      DestroyDeffunctionAction,
                      DeffunctionData(theEnv)->CL_DeffunctionModuleIndex,false,NULL);

   for (theModule = CL_GetNextDefmodule(theEnv,NULL);
        theModule != NULL;
        theModule = CL_GetNextDefmodule(theEnv,theModule))
     {
      theModuleItem = (struct deffunctionModuleData *)
                      CL_GetModuleItem(theEnv,theModule,
                                    DeffunctionData(theEnv)->CL_DeffunctionModuleIndex);
      rtn_struct(theEnv,deffunctionModuleData,theModuleItem);
     }
#else
#if MAC_XCD
#pragma unused(theEnv)
#endif
#endif
  }

#if ! RUN_TIME
/*****************************************************/
/* DestroyDeffunctionAction: Action used to remove   */
/*   deffunctions as a result of CL_DestroyEnvironment. */
/*****************************************************/
static void DestroyDeffunctionAction(
  Environment *theEnv,
  ConstructHeader *theConstruct,
  void *buffer)
  {
#if MAC_XCD
#pragma unused(buffer)
#endif
#if (! BLOAD_ONLY) && (! RUN_TIME)
   Deffunction *theDeffunction = (Deffunction *) theConstruct;

   if (theDeffunction == NULL) return;

   CL_ReturnPackedExpression(theEnv,theDeffunction->code);

   CL_DestroyConstructHeader(theEnv,&theDeffunction->header);

   rtn_struct(theEnv,deffunction,theDeffunction);
#else
#if MAC_XCD
#pragma unused(theConstruct,theEnv)
#endif
#endif
  }
#endif

/***************************************************
  NAME         : CL_FindDeffunction
  DESCRIPTION  : Searches for a deffunction
  INPUTS       : The name of the deffunction
                 (possibly including a module name)
  RETURNS      : Pointer to the deffunction if
                 found, otherwise NULL
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Deffunction *CL_FindDeffunction(
  Environment *theEnv,
  const char *dfnxModuleAndName)
  {
   return (Deffunction *) CL_FindNamedConstructInModuleOrImports(theEnv,dfnxModuleAndName,DeffunctionData(theEnv)->DeffunctionConstruct);
  }

/***************************************************
  NAME         : CL_FindDeffunctionInModule
  DESCRIPTION  : Searches for a deffunction
  INPUTS       : The name of the deffunction
                 (possibly including a module name)
  RETURNS      : Pointer to the deffunction if
                 found, otherwise NULL
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Deffunction *CL_FindDeffunctionInModule(
  Environment *theEnv,
  const char *dfnxModuleAndName)
  {
   return (Deffunction *) CL_FindNamedConstructInModule(theEnv,dfnxModuleAndName,DeffunctionData(theEnv)->DeffunctionConstruct);
  }

/***************************************************
  NAME         : CL_LookupDeffunctionByMdlOrScope
  DESCRIPTION  : Finds a deffunction anywhere (if
                 module is specified) or in current
                 or imported modules
  INPUTS       : The deffunction name
  RETURNS      : The deffunction (NULL if not found)
  SIDE EFFECTS : Error message printed on
                  ambiguous references
  NOTES        : None
 ***************************************************/
Deffunction *CL_LookupDeffunctionByMdlOrScope(
  Environment *theEnv,
  const char *deffunctionName)
  {
   return((Deffunction *) CL_LookupConstruct(theEnv,DeffunctionData(theEnv)->DeffunctionConstruct,deffunctionName,true));
  }

/***************************************************
  NAME         : CL_LookupDeffunctionInScope
  DESCRIPTION  : Finds a deffunction in current or
                   imported modules (module
                   specifier is not allowed)
  INPUTS       : The deffunction name
  RETURNS      : The deffunction (NULL if not found)
  SIDE EFFECTS : Error message printed on
                  ambiguous references
  NOTES        : None
 ***************************************************/
Deffunction *CL_LookupDeffunctionInScope(
  Environment *theEnv,
  const char *deffunctionName)
  {
   return (Deffunction *) CL_LookupConstruct(theEnv,DeffunctionData(theEnv)->DeffunctionConstruct,deffunctionName,false);
  }

/***************************************************
  NAME         : CL_Undeffunction
  DESCRIPTION  : External interface routine for
                 removing a deffunction
  INPUTS       : Deffunction pointer
  RETURNS      : False if unsuccessful,
                 true otherwise
  SIDE EFFECTS : Deffunction deleted, if possible
  NOTES        : None
 ***************************************************/
bool CL_Undeffunction(
  Deffunction *theDeffunction,
  Environment *allEnv)
  {   
#if BLOAD_ONLY || RUN_TIME
   return false;
#else
   Environment *theEnv;
   bool success;
   GCBlock gcb;
  
   if (theDeffunction == NULL)
     { theEnv = allEnv; }
   else
     { theEnv = theDeffunction->header.env; }

#if BLOAD || BLOAD_AND_BSAVE
   if (CL_Bloaded(theEnv) == true)
     return false;
#endif

   CL_GCBlockStart(theEnv,&gcb);
   if (theDeffunction == NULL)
     {
      success = RemoveAllDeffunctions(theEnv);
      CL_GCBlockEnd(theEnv,&gcb);
      return success;
     }
      
   if (CL_DeffunctionIsDeletable(theDeffunction) == false)
     {
      CL_GCBlockEnd(theEnv,&gcb);
      return false;
     }
     
   CL_RemoveConstructFromModule(theEnv,&theDeffunction->header);
   CL_RemoveDeffunction(theEnv,theDeffunction);
   CL_GCBlockEnd(theEnv,&gcb);

   return true;
#endif
  }

/****************************************************
  NAME         : CL_GetNextDeffunction
  DESCRIPTION  : Accesses list of deffunctions
  INPUTS       : Deffunction pointer
  RETURNS      : The next deffunction, or the
                 first deffunction (if input is NULL)
  SIDE EFFECTS : None
  NOTES        : None
 ****************************************************/
Deffunction *CL_GetNextDeffunction(
  Environment *theEnv,
  Deffunction *theDeffunction)
  {
   return (Deffunction *)
          CL_GetNextConstructItem(theEnv,&theDeffunction->header,
                               DeffunctionData(theEnv)->CL_DeffunctionModuleIndex);
  }

/***************************************************
  NAME         : CL_DeffunctionIsDeletable
  DESCRIPTION  : DeteCL_rmines if a deffunction is
                 executing or referenced by another
                 expression
  INPUTS       : Deffunction pointer
  RETURNS      : True if the deffunction can
                 be deleted, false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
bool CL_DeffunctionIsDeletable(
  Deffunction *theDeffunction)
  {
   Environment *theEnv = theDeffunction->header.env;

   if (! CL_ConstructsDeletable(theEnv))
     { return false; }

   return(((theDeffunction->busy == 0) && (theDeffunction->executing == 0)) ? true : false);
  }

#if (! BLOAD_ONLY) && (! RUN_TIME)

/***************************************************
  NAME         : CL_RemoveDeffunction
  DESCRIPTION  : Removes a deffunction
  INPUTS       : Deffunction pointer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Deffunction deallocated
  NOTES        : Assumes deffunction is not in use!!
 ***************************************************/
void CL_RemoveDeffunction(
  Environment *theEnv,
  Deffunction *theDeffunction)
  {
   if (theDeffunction == NULL)
     return;
   CL_ReleaseLexeme(theEnv,GetCL_DeffunctionNamePointer(theEnv,theDeffunction));
   CL_ExpressionDeinstall(theEnv,theDeffunction->code);
   CL_ReturnPackedExpression(theEnv,theDeffunction->code);
   SetCL_DeffunctionPPFoCL_rm(theEnv,theDeffunction,NULL);
   CL_ClearUserDataList(theEnv,theDeffunction->header.usrData);
   rtn_struct(theEnv,deffunction,theDeffunction);
  }

#endif

/********************************************************
  NAME         : CL_UndeffunctionCommand
  DESCRIPTION  : Deletes the named deffunction(s)
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Deffunction(s) removed
  NOTES        : H/L Syntax: (undeffunction <name> | *)
 ********************************************************/
void CL_UndeffunctionCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_UndefconstructCommand(context,"undeffunction",DeffunctionData(theEnv)->DeffunctionConstruct);
  }

/****************************************************************
  NAME         : GetCL_DeffunctionModuleCommand
  DESCRIPTION  : DeteCL_rmines to which module a deffunction belongs
  INPUTS       : None
  RETURNS      : The symbolic name of the module
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (deffunction-module <dfnx-name>)
 ****************************************************************/
void GetCL_DeffunctionModuleCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   returnValue->value = CL_GetConstructModuleCommand(context,"deffunction-module",DeffunctionData(theEnv)->DeffunctionConstruct);
  }

#if DEBUGGING_FUNCTIONS

/****************************************************
  NAME         : CL_PPDeffunctionCommand
  DESCRIPTION  : Displays the pretty-print foCL_rm of a
                 deffunction
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Pretty-print foCL_rm displayed to
                 STDOUT logical name
  NOTES        : H/L Syntax: (ppdeffunction <name>)
 ****************************************************/
void CL_PPDeffunctionCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_PPConstructCommand(context,"ppdeffunction",DeffunctionData(theEnv)->DeffunctionConstruct,returnValue);
  }

/***************************************************
  NAME         : CL_ListDeffunctionsCommand
  DESCRIPTION  : Displays all deffunction names
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Deffunction name sprinted
  NOTES        : H/L Interface
 ***************************************************/
void CL_ListDeffunctionsCommand(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_ListConstructCommand(context,DeffunctionData(theEnv)->DeffunctionConstruct);
  }

/***************************************************
  NAME         : CL_ListDeffunctions
  DESCRIPTION  : Displays all deffunction names
  INPUTS       : 1) The logical name of the output
                 2) The module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Deffunction name sprinted
  NOTES        : C Interface
 ***************************************************/
void CL_ListDeffunctions(
  Environment *theEnv,
  const char *logicalName,
  Defmodule *theModule)
  {
   CL_ListConstruct(theEnv,DeffunctionData(theEnv)->DeffunctionConstruct,logicalName,theModule);
  }

#endif

/***************************************************************
  NAME         : CL_GetDeffunctionListFunction
  DESCRIPTION  : Groups all deffunction names into
                 a multifield list
  INPUTS       : A data object buffer to hold
                 the multifield result
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : H/L Syntax: (get-deffunction-list [<module>])
 ***************************************************************/
void CL_GetDeffunctionListFunction(
  Environment *theEnv,
  UDFContext *context,
  UDFValue *returnValue)
  {
   CL_GetConstructListFunction(context,returnValue,DeffunctionData(theEnv)->DeffunctionConstruct);
  }

/***************************************************************
  NAME         : CL_GetDeffunctionList
  DESCRIPTION  : Groups all deffunction names into
                 a multifield list
  INPUTS       : 1) A data object buffer to hold
                    the multifield result
                 2) The module from which to obtain deffunctions
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : External C access
 ***************************************************************/
void CL_GetDeffunctionList(
  Environment *theEnv,
  CLIPSValue *returnValue,
  Defmodule *theModule)
  {
   UDFValue result;
   
   CL_GetConstructList(theEnv,&result,DeffunctionData(theEnv)->DeffunctionConstruct,theModule);
   CL_NoCL_rmalizeMultifield(theEnv,&result);
   returnValue->value = result.value;
  }

/*******************************************************
  NAME         : CL_CheckDeffunctionCall
  DESCRIPTION  : Checks the number of arguments
                 passed to a deffunction
  INPUTS       : 1) Deffunction pointer
                 2) The number of arguments
  RETURNS      : True if OK, false otherwise
  SIDE EFFECTS : Message printed on errors
  NOTES        : None
 *******************************************************/
bool CL_CheckDeffunctionCall(
  Environment *theEnv,
  Deffunction *theDeffunction,
  int args)
  {
   if (theDeffunction == NULL)
     return false;

   if (args < theDeffunction->minNumberOfParameters)
     {
      if (theDeffunction->maxNumberOfParameters == PARAMETERS_UNBOUNDED)
        CL_ExpectedCountError(theEnv,CL_DeffunctionName(theDeffunction),
                           AT_LEAST,theDeffunction->minNumberOfParameters);
      else
        CL_ExpectedCountError(theEnv,CL_DeffunctionName(theDeffunction),
                           EXACTLY,theDeffunction->minNumberOfParameters);
      return false;
     }
   else if ((args > theDeffunction->minNumberOfParameters) &&
            (theDeffunction->maxNumberOfParameters != PARAMETERS_UNBOUNDED))
     {
      CL_ExpectedCountError(theEnv,CL_DeffunctionName(theDeffunction),
                         EXACTLY,theDeffunction->minNumberOfParameters);
      return false;
     }
   return true;
  }

/* =========================================
   *****************************************
          INTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***************************************************
  NAME         : PrintDeffunctionCall
  DESCRIPTION  : CL_PrintExpression() support function
                 for deffunction calls
  INPUTS       : 1) The output logical name
                 2) The deffunction
  RETURNS      : Nothing useful
  SIDE EFFECTS : Call expression printed
  NOTES        : None
 ***************************************************/
static void PrintDeffunctionCall(
  Environment *theEnv,
  const char *logName,
  Deffunction *theDeffunction)
  {
#if DEVELOPER

   CL_WriteString(theEnv,logName,"(");
   CL_WriteString(theEnv,logName,CL_DeffunctionName(theDeffunction));
   if (GetFirstArgument() != NULL)
     {
      CL_WriteString(theEnv,logName," ");
      CL_PrintExpression(theEnv,logName,GetFirstArgument());
     }
   CL_WriteString(theEnv,logName,")");
#else
#if MAC_XCD
#pragma unused(theEnv)
#pragma unused(logName)
#pragma unused(theDeffunction)
#endif
#endif
  }

/*******************************************************
  NAME         : CL_EvaluateDeffunctionCall
  DESCRIPTION  : Primitive support function for
                 calling a deffunction
  INPUTS       : 1) The deffunction
                 2) A data object buffer to hold
                    the evaluation result
  RETURNS      : False if the deffunction
                 returns the symbol false,
                 true otherwise
  SIDE EFFECTS : Data obejct buffer set and any
                 side-effects of calling the deffunction
  NOTES        : None
 *******************************************************/
static bool CL_EvaluateDeffunctionCall(
  Environment *theEnv,
  Deffunction *theDeffunction,
  UDFValue *returnValue)
  {
   CL_CallDeffunction(theEnv,theDeffunction,GetFirstArgument(),returnValue);
   if (returnValue->value == FalseSymbol(theEnv))
     { return false; }
   return true;
  }

/***************************************************
  NAME         : DecrementDeffunctionBusyCount
  DESCRIPTION  : Lowers the busy count of a
                 deffunction construct
  INPUTS       : The deffunction
  RETURNS      : Nothing useful
  SIDE EFFECTS : Busy count decremented if a clear
                 is not in progress (see comment)
  NOTES        : None
 ***************************************************/
static void DecrementDeffunctionBusyCount(
  Environment *theEnv,
  Deffunction *theDeffunction)
  {
   /* ==============================================
      The deffunctions to which expressions in other
      constructs may refer may already have been
      deleted - thus, it is important not to modify
      the busy flag during a clear.
      ============================================== */
   if (! ConstructData(theEnv)->CL_ClearInProgress)
     theDeffunction->busy--;
  }

/***************************************************
  NAME         : IncrementDeffunctionBusyCount
  DESCRIPTION  : Raises the busy count of a
                 deffunction construct
  INPUTS       : The deffunction
  RETURNS      : Nothing useful
  SIDE EFFECTS : Busy count incremented
  NOTES        : None
 ***************************************************/
static void IncrementDeffunctionBusyCount(
  Environment *theEnv,
  Deffunction *theDeffunction)
  {
#if MAC_XCD
#pragma unused(theEnv)
#endif
#if (! RUN_TIME) && (! BLOAD_ONLY)
   if (! ConstructData(theEnv)->ParsingConstruct)
     { ConstructData(theEnv)->DanglingConstructs++; }
#endif

   theDeffunction->busy++;
  }

#if ! RUN_TIME

/*****************************************************
  NAME         : AllocateModule
  DESCRIPTION  : Creates and initializes a
                 list of deffunctions for a new module
  INPUTS       : None
  RETURNS      : The new deffunction module
  SIDE EFFECTS : Deffunction module created
  NOTES        : None
 *****************************************************/
static void *AllocateModule(
  Environment *theEnv)
  {
   return (void *) get_struct(theEnv,deffunctionModuleData);
  }

/***************************************************
  NAME         : ReturnModule
  DESCRIPTION  : Removes a deffunction module and
                 all associated deffunctions
  INPUTS       : The deffunction module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Module and deffunctions deleted
  NOTES        : None
 ***************************************************/
static void ReturnModule(
  Environment *theEnv,
  void *theItem)
  {
#if (! BLOAD_ONLY)
   CL_FreeConstructHeaderModule(theEnv,(struct defmoduleItemHeader *) theItem,DeffunctionData(theEnv)->DeffunctionConstruct);
#endif
   rtn_struct(theEnv,deffunctionModuleData,theItem);
  }

/***************************************************
  NAME         : CL_ClearDeffunctionsReady
  DESCRIPTION  : DeteCL_rmines if it is safe to
                 remove all deffunctions
                 Assumes *all* constructs will be
                 deleted - only checks to see if
                 any deffunctions are currently
                 executing
  INPUTS       : None
  RETURNS      : True if no deffunctions are
                 executing, false otherwise
  SIDE EFFECTS : None
  NOTES        : Used by (clear) and (bload)
 ***************************************************/
static bool CL_ClearDeffunctionsReady(
  Environment *theEnv,
  void *context)
  {
   return((DeffunctionData(theEnv)->ExecutingDeffunction != NULL) ? false : true);
  }

#endif

#if RUN_TIME

/**************************************************/
/* CL_RuntimeDeffunctionAction: Action to be applied */
/*   to each deffunction construct when a runtime */
/*   initialization occurs.                       */
/**************************************************/
static void CL_RuntimeDeffunctionAction(
  Environment *theEnv,
  ConstructHeader *theConstruct,
  void *buffer)
  {
#if MAC_XCD
#pragma unused(buffer)
#endif
   Deffunction *theDeffunction = (Deffunction *) theConstruct;
   
   theDeffunction->header.env = theEnv;
  }

/*********************************/
/* DeffunctionCL_RunTimeInitialize: */
/*********************************/
void DeffunctionCL_RunTimeInitialize(
  Environment *theEnv)
  {
   CL_DoForAllConstructs(theEnv,CL_RuntimeDeffunctionAction,DeffunctionData(theEnv)->CL_DeffunctionModuleIndex,true,NULL);
  }

#endif

#if (! BLOAD_ONLY) && (! RUN_TIME)

/***************************************************
  NAME         : RemoveAllDeffunctions
  DESCRIPTION  : Removes all deffunctions
  INPUTS       : None
  RETURNS      : True if all deffunctions
                 removed, false otherwise
  SIDE EFFECTS : Deffunctions removed
  NOTES        : None
 ***************************************************/
static bool RemoveAllDeffunctions(
  Environment *theEnv)
  {
   Deffunction *dptr, *dtmp;
   unsigned oldbusy;
   bool success = true;

#if BLOAD || BLOAD_AND_BSAVE

   if (CL_Bloaded(theEnv) == true)
     return false;
#endif

   dptr = CL_GetNextDeffunction(theEnv,NULL);
   while (dptr != NULL)
     {
      if (dptr->executing > 0)
        {
         DeffunctionDeleteError(theEnv,CL_DeffunctionName(dptr));
         success = false;
        }
      else
        {
         oldbusy = dptr->busy;
         CL_ExpressionDeinstall(theEnv,dptr->code);
         dptr->busy = oldbusy;
         CL_ReturnPackedExpression(theEnv,dptr->code);
         dptr->code = NULL;
        }
      dptr = CL_GetNextDeffunction(theEnv,dptr);
     }

   dptr = CL_GetNextDeffunction(theEnv,NULL);
   while (dptr != NULL)
     {
      dtmp = dptr;
      dptr = CL_GetNextDeffunction(theEnv,dptr);
      if (dtmp->executing == 0)
        {
         if (dtmp->busy > 0)
           {
            CL_PrintWarningID(theEnv,"DFFNXFUN",1,false);
            CL_WriteString(theEnv,STDWRN,"Deffunction '");
            CL_WriteString(theEnv,STDWRN,CL_DeffunctionName(dtmp));
            CL_WriteString(theEnv,STDWRN,"' only partially deleted due to usage by other constructs.\n");
            SetCL_DeffunctionPPFoCL_rm(theEnv,dtmp,NULL);
            success = false;
           }
         else
           {
            CL_RemoveConstructFromModule(theEnv,&dtmp->header);
            CL_RemoveDeffunction(theEnv,dtmp);
           }
        }
     }
   return(success);
  }

/****************************************************
  NAME         : DeffunctionDeleteError
  DESCRIPTION  : Prints out an error message when
                 a deffunction deletion attempt fails
  INPUTS       : The deffunction name
  RETURNS      : Nothing useful
  SIDE EFFECTS : Error message printed
  NOTES        : None
 ****************************************************/
static void DeffunctionDeleteError(
  Environment *theEnv,
  const char *dfnxName)
  {
   CL_CantDeleteItemErrorMessage(theEnv,"deffunction",dfnxName);
  }

/***************************************************
  NAME         : CL_SaveDeffunctionHeaders
  DESCRIPTION  : CL_Writes out deffunction forward
                 declarations for (save) command
  INPUTS       : The logical output name
  RETURNS      : Nothing useful
  SIDE EFFECTS : CL_Writes out deffunctions with no
                 body of actions
  NOTES        : Used for deffunctions which are
                 mutually recursive with other
                 constructs
 ***************************************************/
static void CL_SaveDeffunctionHeaders(
  Environment *theEnv,
  Defmodule *theModule,
  const char *logicalName,
  void *context)
  {
   CL_DoForAllConstructsInModule(theEnv,theModule,
                              CL_SaveDeffunctionHeader,
                              DeffunctionData(theEnv)->CL_DeffunctionModuleIndex,
                              false,(void *) logicalName);
  }

/***************************************************
  NAME         : CL_SaveDeffunctionHeader
  DESCRIPTION  : CL_Writes a deffunction forward
                 declaration to the save file
  INPUTS       : 1) The deffunction
                 2) The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : Defffunction header written
  NOTES        : None
 ***************************************************/
static void CL_SaveDeffunctionHeader(
  Environment *theEnv,
  ConstructHeader *theDeffunction,
  void *userBuffer)
  {
   Deffunction *dfnxPtr = (Deffunction *) theDeffunction;
   const char *logicalName = (const char *) userBuffer;
   unsigned short i;

   if (CL_DeffunctionPPFoCL_rm(dfnxPtr) != NULL)
     {
      CL_WriteString(theEnv,logicalName,"(deffunction ");
      CL_WriteString(theEnv,logicalName,CL_DeffunctionModule(dfnxPtr));
      CL_WriteString(theEnv,logicalName,"::");
      CL_WriteString(theEnv,logicalName,CL_DeffunctionName(dfnxPtr));
      CL_WriteString(theEnv,logicalName," (");
      for (i = 0 ; i < dfnxPtr->minNumberOfParameters ; i++)
        {
         CL_WriteString(theEnv,logicalName,"?p");
         CL_PrintUnsignedInteger(theEnv,logicalName,i);
         if ((i + 1) != dfnxPtr->minNumberOfParameters)
           CL_WriteString(theEnv,logicalName," ");
        }
      if (dfnxPtr->maxNumberOfParameters == PARAMETERS_UNBOUNDED)
        {
         if (dfnxPtr->minNumberOfParameters != 0)
           CL_WriteString(theEnv,logicalName," ");
         CL_WriteString(theEnv,logicalName,"$?wildargs))\n\n");
        }
      else
        CL_WriteString(theEnv,logicalName,"))\n\n");
     }
  }

/***************************************************
  NAME         : CL_SaveDeffunctions
  DESCRIPTION  : CL_Writes out deffunctions
                 for (save) command
  INPUTS       : The logical output name
  RETURNS      : Nothing useful
  SIDE EFFECTS : CL_Writes out deffunctions
  NOTES        : None
 ***************************************************/
static void CL_SaveDeffunctions(
  Environment *theEnv,
  Defmodule *theModule,
  const char *logicalName,
  void *context)
  {
   CL_SaveConstruct(theEnv,theModule,logicalName,DeffunctionData(theEnv)->DeffunctionConstruct);
  }

#endif

#if DEBUGGING_FUNCTIONS

/******************************************************************
  NAME         : DeffunctionCL_WatchAccess
  DESCRIPTION  : Parses a list of deffunction names passed by
                 CL_AddCL_WatchItem() and sets the traces accordingly
  INPUTS       : 1) A code indicating which trace flag is to be set
                    Ignored
                 2) The value to which to set the trace flags
                 3) A list of expressions containing the names
                    of the deffunctions for which to set traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : CL_Watch flags set in specified deffunctions
  NOTES        : Accessory function for CL_AddCL_WatchItem()
 ******************************************************************/
static bool DeffunctionCL_WatchAccess(
  Environment *theEnv,
  int code,
  bool newState,
  Expression *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif

   return(CL_ConstructSetCL_WatchAccess(theEnv,DeffunctionData(theEnv)->DeffunctionConstruct,newState,argExprs,
                                  (ConstructGetCL_WatchFunction *) CL_DeffunctionGetCL_Watch,
                                  (ConstructSetCL_WatchFunction *) CL_DeffunctionSetCL_Watch));
  }

/***********************************************************************
  NAME         : DeffunctionCL_WatchPrint
  DESCRIPTION  : Parses a list of deffunction names passed by
                 CL_AddCL_WatchItem() and displays the traces accordingly
  INPUTS       : 1) The logical name of the output
                 2) A code indicating which trace flag is to be examined
                    Ignored
                 3) A list of expressions containing the names
                    of the deffunctions for which to examine traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : CL_Watch flags displayed for specified deffunctions
  NOTES        : Accessory function for CL_AddCL_WatchItem()
 ***********************************************************************/
static bool DeffunctionCL_WatchPrint(
  Environment *theEnv,
  const char *logName,
  int code,
  Expression *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif

   return(CL_ConstructPrintCL_WatchAccess(theEnv,DeffunctionData(theEnv)->DeffunctionConstruct,logName,argExprs,
                                    (ConstructGetCL_WatchFunction *) CL_DeffunctionGetCL_Watch,
                                    (ConstructSetCL_WatchFunction *) CL_DeffunctionSetCL_Watch));
  }

/*********************************************************
  NAME         : CL_DeffunctionSetCL_Watch
  DESCRIPTION  : Sets the trace to ON/OFF for the
                 deffunction
  INPUTS       : 1) True to set the trace on,
                    false to set it off
                 2) A pointer to the deffunction
  RETURNS      : Nothing useful
  SIDE EFFECTS : CL_Watch flag for the deffunction set
  NOTES        : None
 *********************************************************/
void CL_DeffunctionSetCL_Watch(
  Deffunction *theDeffunction,
  bool newState)
  {
   theDeffunction->trace = newState;
  }

/*********************************************************
  NAME         : CL_DeffunctionGetCL_Watch
  DESCRIPTION  : DeteCL_rmines if trace messages are
                 gnerated when executing deffunction
  INPUTS       : A pointer to the deffunction
  RETURNS      : True if a trace is active,
                 false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 *********************************************************/
bool CL_DeffunctionGetCL_Watch(
  Deffunction *theDeffunction)
  {
   return theDeffunction->trace;
  }

#endif

/*##################################*/
/* Additional Environment Functions */
/*##################################*/

const char *CL_DeffunctionModule(
  Deffunction *theDeffunction)
  {
   return CL_GetConstructModuleName(&theDeffunction->header);
  }

const char *CL_DeffunctionName(
  Deffunction *theDeffunction)
  {
   return CL_GetConstructNameString(&theDeffunction->header);
  }

const char *CL_DeffunctionPPFoCL_rm(
  Deffunction *theDeffunction)
  {
   return CL_GetConstructPPFoCL_rm(&theDeffunction->header);
  }

CLIPSLexeme *GetCL_DeffunctionNamePointer(
  Environment *theEnv,
  Deffunction *theDeffunction)
  {
   return CL_GetConstructNamePointer(&theDeffunction->header);
  }

void SetCL_DeffunctionPPFoCL_rm(
  Environment *theEnv,
  Deffunction *theDeffunction,
  const char *thePPFoCL_rm)
  {
   SetConstructPPFoCL_rm(theEnv,&theDeffunction->header,thePPFoCL_rm);
  }

#endif


