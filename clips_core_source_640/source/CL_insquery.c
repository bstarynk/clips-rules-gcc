   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  09/28/17             */
   /*                                                     */
   /*                                                     */
   /*******************************************************/

/*************************************************************/
/* Purpose: Query Functions for Objects                      */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Gary D. Riley                                        */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*      6.24: Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Changed integer type/precision.                */
/*                                                           */
/*            Changed garbage collection algorithm.          */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*      6.31: Retrieval for instance query slot function     */
/*            generates an error if the instance has been    */
/*            deleted.                                       */
/*                                                           */
/*            Functions delayed-do-for-all-instances and     */
/*            do-for-instance increment the busy count of    */
/*            matching instance sets so that actions can     */
/*            detect deleted instances.                      */
/*                                                           */
/*            Matching instance sets containing deleted      */
/*            instances are pruned.                          */
/*                                                           */
/*      6.40: Added Env prefix to Get_EvaluationError and     */
/*            Set_EvaluationError functions.                  */
/*                                                           */
/*            Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*            Added CL_GCBlockStart and CL_GCBlockEnd functions    */
/*            for garbage collection blocks.                 */
/*                                                           */
/*            CL_Eval support for run time and bload only.      */
/*                                                           */
/*************************************************************/

/* =========================================
   *****************************************
               EXTERNAL DEFINITIONS
   =========================================
   ***************************************** */
#include "setup.h"

#if INSTANCE_SET_QUERIES

#include "argacces.h"
#include "classcom.h"
#include "classfun.h"
#include "envrnmnt.h"
#include "exprnpsr.h"
#include "insfun.h"
#include "insmngr.h"
#include "insqypsr.h"
#include "memalloc.h"
#include "prcdrfun.h"
#include "prntutil.h"
#include "router.h"
#include "utility.h"

#include "insquery.h"

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

static void PushQueryCore (Environment *);
static void PopQueryCore (Environment *);
static QUERY_CORE *FindQueryCore (Environment *, long long);
static QUERY_CLASS *Dete_rmineQueryClasses (Environment *, Expression *,
					    const char *, unsigned *);
static QUERY_CLASS *Fo_rmChain (Environment *, const char *, Defclass *,
				UDFValue *);
static void DeleteQueryClasses (Environment *, QUERY_CLASS *);
static bool TestForFirstInChain (Environment *, QUERY_CLASS *, unsigned);
static bool TestForFirstInstanceInClass (Environment *, Defmodule *, int,
					 Defclass *, QUERY_CLASS *, unsigned);
static void TestEntireChain (Environment *, QUERY_CLASS *, unsigned);
static void TestEntireClass (Environment *, Defmodule *, int, Defclass *,
			     QUERY_CLASS *, unsigned);
static void AddSolution (Environment *);
static void PopQuerySoln (Environment *);

/****************************************************
  NAME         : CL_SetupQuery
  DESCRIPTION  : Initializes instance query H/L
                   functions and parsers
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Sets up kernel functions and parsers
  NOTES        : None
 ****************************************************/
void
CL_SetupQuery (Environment * theEnv)
{
  CL_AllocateEnvironmentData (theEnv, INSTANCE_QUERY_DATA,
			      sizeof (struct instanceQueryData), NULL);

#if ! RUN_TIME
  InstanceQueryData (theEnv)->QUERY_DELIMITER_SYMBOL =
    CL_CreateSymbol (theEnv, QUERY_DELIMITER_STRING);
  IncrementLexemeCount (InstanceQueryData (theEnv)->QUERY_DELIMITER_SYMBOL);

  CL_AddUDF (theEnv, "(query-instance)", "n", 0, UNBOUNDED, NULL,
	     CL_GetQueryInstance, "CL_GetQueryInstance", NULL);

  CL_AddUDF (theEnv, "(query-instance-slot)", "*", 0, UNBOUNDED, NULL,
	     CL_GetQueryInstanceSlot, "CL_GetQueryInstanceSlot", NULL);

  CL_AddUDF (theEnv, "any-instancep", "b", 0, UNBOUNDED, NULL,
	     CL_Any_Instances, "CL_Any_Instances", NULL);

  CL_AddUDF (theEnv, "find-instance", "m", 0, UNBOUNDED, NULL,
	     Query_FindInstance, "Query_FindInstance", NULL);

  CL_AddUDF (theEnv, "find-all-instances", "m", 0, UNBOUNDED, NULL,
	     QueryFindAll_Instances, "QueryFindAll_Instances", NULL);

  CL_AddUDF (theEnv, "do-for-instance", "*", 0, UNBOUNDED, NULL,
	     CL_QueryDoForInstance, "CL_QueryDoForInstance", NULL);

  CL_AddUDF (theEnv, "do-for-all-instances", "*", 0, UNBOUNDED, NULL,
	     QueryDoForAll_Instances, "QueryDoForAll_Instances", NULL);

  CL_AddUDF (theEnv, "delayed-do-for-all-instances", "*", 0, UNBOUNDED, NULL,
	     CL_DelayedQueryDoForAll_Instances,
	     "CL_DelayedQueryDoForAll_Instances", NULL);
#endif

  CL_AddFunctionParser (theEnv, "any-instancep", CL_ParseQueryNoAction);
  CL_AddFunctionParser (theEnv, "find-instance", CL_ParseQueryNoAction);
  CL_AddFunctionParser (theEnv, "find-all-instances", CL_ParseQueryNoAction);
  CL_AddFunctionParser (theEnv, "do-for-instance", CL_ParseQueryAction);
  CL_AddFunctionParser (theEnv, "do-for-all-instances", CL_ParseQueryAction);
  CL_AddFunctionParser (theEnv, "delayed-do-for-all-instances",
			CL_ParseQueryAction);
}

/*************************************************************
  NAME         : CL_GetQueryInstance
  DESCRIPTION  : Internal function for referring to instance
                    array on instance-queries
  INPUTS       : None
  RETURNS      : The name of the specified instance-set member
  SIDE EFFECTS : None
  NOTES        : H/L Syntax : ((query-instance) <index>)
 *************************************************************/
void
CL_GetQueryInstance (Environment * theEnv,
		     UDFContext * context, UDFValue * returnValue)
{
  QUERY_CORE *core;

  core = FindQueryCore (theEnv, GetFirstArgument ()->integerValue->contents);
  returnValue->value =
    CL_GetFull_InstanceName (theEnv,
			     core->solns[GetFirstArgument ()->nextArg->
					 integerValue->contents]);
}

/***************************************************************************
  NAME         : CL_GetQueryInstanceSlot
  DESCRIPTION  : Internal function for referring to slots of instances in
                    instance array on instance-queries
  INPUTS       : The caller's result buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Caller's result buffer set appropriately
  NOTES        : H/L Syntax : ((query-instance-slot) <index> <slot-name>)
 **************************************************************************/
void
CL_GetQueryInstanceSlot (Environment * theEnv,
			 UDFContext * context, UDFValue * returnValue)
{
  Instance *ins;
  InstanceSlot *sp;
  UDFValue temp;
  QUERY_CORE *core;
  const char *varSlot;

  returnValue->lexemeValue = FalseSymbol (theEnv);

  core = FindQueryCore (theEnv, GetFirstArgument ()->integerValue->contents);
  ins = core->solns[GetFirstArgument ()->nextArg->integerValue->contents];
  varSlot =
    GetFirstArgument ()->nextArg->nextArg->nextArg->lexemeValue->contents;

   /*=======================================*/
  /* Accessing the slot value of a deleted */
  /* instance generates an error.          */
   /*=======================================*/

  if (ins->garbage)
    {
      CL_InstanceVarSlotErrorMessage1 (theEnv, ins, varSlot);
      Set_EvaluationError (theEnv, true);
      return;
    }

  CL_EvaluateExpression (theEnv, GetFirstArgument ()->nextArg->nextArg,
			 &temp);
  if (temp.header->type != SYMBOL_TYPE)
    {
      CL_InvalidVarSlotErrorMessage (theEnv, varSlot);
      Set_EvaluationError (theEnv, true);
      return;
    }
  sp = CL_FindInstanceSlot (theEnv, ins, temp.lexemeValue);
  if (sp == NULL)
    {
      CL_InstanceVarSlotErrorMessage2 (theEnv, ins, varSlot);
      Set_EvaluationError (theEnv, true);
      return;
    }
  returnValue->value = sp->value;
  if (sp->type == MULTIFIELD_TYPE)
    {
      returnValue->begin = 0;
      returnValue->range = sp->multifieldValue->length;
    }
}

/* =============================================================================
   =============================================================================
   Following are the instance query functions :

     any-instancep         : Dete_rmines if any instances satisfy the query
     find-instance         : Finds first (set of) instance(s) which satisfies
                               the query and stores it in a multi-field
     find-all-instances    : Finds all (sets of) instances which satisfy the
                               the query and stores them in a multi-field
     do-for-instance       : Executes a given action for the first (set of)
                               instance(s) which satisfy the query
     do-for-all-instances  : Executes an action for all instances which satisfy
                               the query as they are found
     delayed-do-for-all-instances : Same as above - except that the list of instances
                               which satisfy the query is fo_rmed before any
                               actions are executed

     Instance candidate search algorithm :

     All pe_rmutations of first restriction class instances with other
       restriction class instances (Rightmost are varied first)
     All pe_rmutations of first restriction class's subclasses' instances with
       other restriction class instances.
     And  so on...

     For any one class, instances are examined in the order they were defined

     Example :
     (defclass a (is-a standard-user))
     (defclass b (is-a standard-user))
     (defclass c (is-a standard-user))
     (defclass d (is-a a b))
     (make-instance a1 of a)
     (make-instance a2 of a)
     (make-instance b1 of b)
     (make-instance b2 of b)
     (make-instance c1 of c)
     (make-instance c2 of c)
     (make-instance d1 of d)
     (make-instance d2 of d)

     (any-instancep ((?a a b) (?b c)) <query>)

     The pe_rmutations (?a ?b) would be examined in the following order :

     (a1 c1),(a1 c2),(a2 c1),(a2 c2),(d1 c1),(d1 c2),(d2 c1),(d2 c2),
     (b1 c1),(b1 c2),(b2 c1),(b2 c2),(d1 c1),(d1 c2),(d2 c1),(d2 c2)

     Notice the duplication because d is a subclass of both and a and b.
   =============================================================================
   ============================================================================= */

/******************************************************************************
  NAME         : CL_Any_Instances
  DESCRIPTION  : Dete_rmines if there any existing instances which satisfy
                   the query
  INPUTS       : None
  RETURNS      : True if the query is satisfied, false otherwise
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   zero or more times (depending on instance restrictions
                   and how early the expression evaulates to true - if at all).
  NOTES        : H/L Syntax : See CL_ParseQueryNoAction()
 ******************************************************************************/
void
CL_Any_Instances (Environment * theEnv,
		  UDFContext * context, UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned rcnt;
  bool testResult;

  qclasses = Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg,
				     "any-instancep", &rcnt);
  if (qclasses == NULL)
    {
      returnValue->lexemeValue = FalseSymbol (theEnv);
      return;
    }

  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns =
    (Instance **) CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  testResult = TestForFirstInChain (theEnv, qclasses, 0);
  InstanceQueryData (theEnv)->AbortQuery = false;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);

  returnValue->lexemeValue = CL_CreateBoolean (theEnv, testResult);
}

/******************************************************************************
  NAME         : Query_FindInstance
  DESCRIPTION  : Finds the first set of instances which satisfy the query and
                   stores their names in the user's multi-field variable
  INPUTS       : Caller's result buffer
  RETURNS      : True if the query is satisfied, false otherwise
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   zero or more times (depending on instance restrictions
                   and how early the expression evaulates to true - if at all).
  NOTES        : H/L Syntax : See CL_ParseQueryNoAction()
 ******************************************************************************/
void
Query_FindInstance (Environment * theEnv,
		    UDFContext * context, UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned rcnt, i;

  returnValue->begin = 0;
  returnValue->range = 0;
  qclasses = Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg,
				     "find-instance", &rcnt);
  if (qclasses == NULL)
    {
      returnValue->value = CL_CreateMultifield (theEnv, 0L);
      return;
    }
  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns = (Instance **)
    CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  if (TestForFirstInChain (theEnv, qclasses, 0) == true)
    {
      returnValue->value = CL_CreateMultifield (theEnv, rcnt);
      returnValue->range = rcnt;
      for (i = 0; i < rcnt; i++)
	{
	  returnValue->multifieldValue->contents[i].lexemeValue =
	    CL_GetFull_InstanceName (theEnv,
				     InstanceQueryData (theEnv)->QueryCore->
				     solns[i]);
	}
    }
  else
    returnValue->value = CL_CreateMultifield (theEnv, 0L);
  InstanceQueryData (theEnv)->AbortQuery = false;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);
}

/******************************************************************************
  NAME         : QueryFindAll_Instances
  DESCRIPTION  : Finds all sets of instances which satisfy the query and
                   stores their names in the user's multi-field variable

                 The sets are stored sequentially :

                   Number of sets = (Multi-field length) / (Set length)

                 The first set is if the first (set length) atoms of the
                   multi-field variable, and so on.
  INPUTS       : Caller's result buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   once for every instance set.
  NOTES        : H/L Syntax : See CL_ParseQueryNoAction()
 ******************************************************************************/
void
QueryFindAll_Instances (Environment * theEnv,
			UDFContext * context, UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned rcnt;
  size_t i, j;

  returnValue->begin = 0;
  returnValue->range = 0;
  qclasses = Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg,
				     "find-all-instances", &rcnt);
  if (qclasses == NULL)
    {
      returnValue->value = CL_CreateMultifield (theEnv, 0L);
      return;
    }
  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns =
    (Instance **) CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  InstanceQueryData (theEnv)->QueryCore->action = NULL;
  InstanceQueryData (theEnv)->QueryCore->soln_set = NULL;
  InstanceQueryData (theEnv)->QueryCore->soln_size = rcnt;
  InstanceQueryData (theEnv)->QueryCore->soln_cnt = 0;
  TestEntireChain (theEnv, qclasses, 0);
  InstanceQueryData (theEnv)->AbortQuery = false;
  returnValue->value =
    CL_CreateMultifield (theEnv,
			 InstanceQueryData (theEnv)->QueryCore->soln_cnt *
			 rcnt);
  while (InstanceQueryData (theEnv)->QueryCore->soln_set != NULL)
    {
      for (i = 0, j = returnValue->range; i < rcnt; i++, j++)
	{
	  returnValue->multifieldValue->contents[j].lexemeValue =
	    CL_GetFull_InstanceName (theEnv,
				     InstanceQueryData (theEnv)->QueryCore->
				     soln_set->soln[i]);
	}
      returnValue->range = j;
      PopQuerySoln (theEnv);
    }
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);
}

/******************************************************************************
  NAME         : CL_QueryDoForInstance
  DESCRIPTION  : Finds the first set of instances which satisfy the query and
                   executes a user-action with that set
  INPUTS       : None
  RETURNS      : Caller's result buffer
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   zero or more times (depending on instance restrictions
                   and how early the expression evaulates to true - if at all).
                   Also the action expression is executed zero or once.
                 Caller's result buffer holds result of user-action
  NOTES        : H/L Syntax : See CL_ParseQueryAction()
 ******************************************************************************/
void
CL_QueryDoForInstance (Environment * theEnv,
		       UDFContext * context, UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned i, rcnt;

  returnValue->lexemeValue = FalseSymbol (theEnv);
  qclasses =
    Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg->nextArg,
			    "do-for-instance", &rcnt);
  if (qclasses == NULL)
    return;
  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns =
    (Instance **) CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  InstanceQueryData (theEnv)->QueryCore->action =
    GetFirstArgument ()->nextArg;

  if (TestForFirstInChain (theEnv, qclasses, 0) == true)
    {
      for (i = 0; i < rcnt; i++)
	{
	  InstanceQueryData (theEnv)->QueryCore->solns[i]->busy++;
	}

      CL_EvaluateExpression (theEnv,
			     InstanceQueryData (theEnv)->QueryCore->action,
			     returnValue);

      for (i = 0; i < rcnt; i++)
	{
	  InstanceQueryData (theEnv)->QueryCore->solns[i]->busy--;
	}
    }

  InstanceQueryData (theEnv)->AbortQuery = false;
  ProcedureFunctionData (theEnv)->BreakFlag = false;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);
}

/******************************************************************************
  NAME         : QueryDoForAll_Instances
  DESCRIPTION  : Finds all sets of instances which satisfy the query and
                   executes a user-function for each set as it is found
  INPUTS       : Caller's result buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   once for every instance set.  Also, the action is
                   executed for every instance set.
                 Caller's result buffer holds result of last action executed.
  NOTES        : H/L Syntax : See CL_ParseQueryAction()
 ******************************************************************************/
void
QueryDoForAll_Instances (Environment * theEnv,
			 UDFContext * context, UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned rcnt;

  returnValue->lexemeValue = FalseSymbol (theEnv);
  qclasses =
    Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg->nextArg,
			    "do-for-all-instances", &rcnt);
  if (qclasses == NULL)
    return;

  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns =
    (Instance **) CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  InstanceQueryData (theEnv)->QueryCore->action =
    GetFirstArgument ()->nextArg;
  InstanceQueryData (theEnv)->QueryCore->result = returnValue;
  CL_RetainUDFV (theEnv, InstanceQueryData (theEnv)->QueryCore->result);
  TestEntireChain (theEnv, qclasses, 0);
  CL_ReleaseUDFV (theEnv, InstanceQueryData (theEnv)->QueryCore->result);

  InstanceQueryData (theEnv)->AbortQuery = false;
  ProcedureFunctionData (theEnv)->BreakFlag = false;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);
}

/******************************************************************************
  NAME         : CL_DelayedQueryDoForAll_Instances
  DESCRIPTION  : Finds all sets of instances which satisfy the query and
                   and exceutes a user-action for each set

                 This function differs from QueryDoForAll_Instances() in
                   that it fo_rms the complete list of query satisfactions
                   BEFORE executing any actions.
  INPUTS       : Caller's result buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : The query class-expressions are evaluated once,
                   and the query boolean-expression is evaluated
                   once for every instance set.  The action is executed
                   for evry query satisfaction.
                 Caller's result buffer holds result of last action executed.
  NOTES        : H/L Syntax : See CL_ParseQueryNoAction()
 ******************************************************************************/
void
CL_DelayedQueryDoForAll_Instances (Environment * theEnv,
				   UDFContext * context,
				   UDFValue * returnValue)
{
  QUERY_CLASS *qclasses;
  unsigned rcnt;
  unsigned i;
  GCBlock gcb;
  QUERY_SOLN *theSet;

  returnValue->lexemeValue = FalseSymbol (theEnv);
  qclasses =
    Dete_rmineQueryClasses (theEnv, GetFirstArgument ()->nextArg->nextArg,
			    "delayed-do-for-all-instances", &rcnt);
  if (qclasses == NULL)
    return;

  PushQueryCore (theEnv);
  InstanceQueryData (theEnv)->QueryCore = get_struct (theEnv, query_core);
  InstanceQueryData (theEnv)->QueryCore->solns =
    (Instance **) CL_gm2 (theEnv, (sizeof (Instance *) * rcnt));
  InstanceQueryData (theEnv)->QueryCore->query = GetFirstArgument ();
  InstanceQueryData (theEnv)->QueryCore->action = NULL;
  InstanceQueryData (theEnv)->QueryCore->soln_set = NULL;
  InstanceQueryData (theEnv)->QueryCore->soln_size = rcnt;
  InstanceQueryData (theEnv)->QueryCore->soln_cnt = 0;
  TestEntireChain (theEnv, qclasses, 0);
  InstanceQueryData (theEnv)->AbortQuery = false;
  InstanceQueryData (theEnv)->QueryCore->action =
    GetFirstArgument ()->nextArg;

   /*==================================================================*/
  /* Increment the busy count for all instances in the solution sets. */
   /*==================================================================*/

  CL_GCBlockStart (theEnv, &gcb);

  for (theSet = InstanceQueryData (theEnv)->QueryCore->soln_set;
       theSet != NULL; theSet = theSet->nxt)
    {
      for (i = 0; i < rcnt; i++)
	{
	  theSet->soln[i]->busy++;
	}
    }

   /*=====================*/
  /* Perfo_rm the action. */
   /*=====================*/

  for (theSet = InstanceQueryData (theEnv)->QueryCore->soln_set;
       theSet != NULL;)
    {
      for (i = 0; i < rcnt; i++)
	{
	  if (theSet->soln[i]->garbage)
	    {
	      goto nextSet;
	    }
	  InstanceQueryData (theEnv)->QueryCore->solns[i] = theSet->soln[i];
	}

      CL_EvaluateExpression (theEnv,
			     InstanceQueryData (theEnv)->QueryCore->action,
			     returnValue);

      if (CL_EvaluationData (theEnv)->CL_HaltExecution
	  || ProcedureFunctionData (theEnv)->BreakFlag
	  || ProcedureFunctionData (theEnv)->ReturnFlag)
	{
	  break;
	}

      CL_CleanCurrentGarbageFrame (theEnv, NULL);
      CL_CallPeriodicTasks (theEnv);

    nextSet:theSet = theSet->nxt;
    }

   /*==================================================================*/
  /* Decrement the busy count for all instances in the solution sets. */
   /*==================================================================*/

  for (theSet = InstanceQueryData (theEnv)->QueryCore->soln_set;
       theSet != NULL; theSet = theSet->nxt)
    {
      for (i = 0; i < rcnt; i++)
	{
	  theSet->soln[i]->busy--;
	}
    }

  CL_GCBlockEndUDF (theEnv, &gcb, returnValue);
  CL_CallPeriodicTasks (theEnv);

   /*==================================*/
  /* Deallocate the query structures. */
   /*==================================*/

  while (InstanceQueryData (theEnv)->QueryCore->soln_set != NULL)
    {
      PopQuerySoln (theEnv);
    }

  ProcedureFunctionData (theEnv)->BreakFlag = false;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->solns,
	 (sizeof (Instance *) * rcnt));
  rtn_struct (theEnv, query_core, InstanceQueryData (theEnv)->QueryCore);
  PopQueryCore (theEnv);
  DeleteQueryClasses (theEnv, qclasses);
}

/* =========================================
   *****************************************
          INTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/*******************************************************
  NAME         : PushQueryCore
  DESCRIPTION  : Pushes the current QueryCore onto stack
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Allocates new stack node and changes
                   QueryCoreStack
  NOTES        : None
 *******************************************************/
static void
PushQueryCore (Environment * theEnv)
{
  QUERY_STACK *qptr;

  qptr = get_struct (theEnv, query_stack);
  qptr->core = InstanceQueryData (theEnv)->QueryCore;
  qptr->nxt = InstanceQueryData (theEnv)->QueryCoreStack;
  InstanceQueryData (theEnv)->QueryCoreStack = qptr;
}

/******************************************************
  NAME         : PopQueryCore
  DESCRIPTION  : Pops top of QueryCore stack and
                   restores QueryCore to this core
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Stack node deallocated, QueryCoreStack
                   changed and QueryCore reset
  NOTES        : Assumes stack is not empty
 ******************************************************/
static void
PopQueryCore (Environment * theEnv)
{
  QUERY_STACK *qptr;

  InstanceQueryData (theEnv)->QueryCore =
    InstanceQueryData (theEnv)->QueryCoreStack->core;
  qptr = InstanceQueryData (theEnv)->QueryCoreStack;
  InstanceQueryData (theEnv)->QueryCoreStack =
    InstanceQueryData (theEnv)->QueryCoreStack->nxt;
  rtn_struct (theEnv, query_stack, qptr);
}

/***************************************************
  NAME         : FindQueryCore
  DESCRIPTION  : Looks up a QueryCore Stack Frame
                    Depth 0 is current frame
                    1 is next deepest, etc.
  INPUTS       : Depth
  RETURNS      : Address of query core stack frame
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
static QUERY_CORE *
FindQueryCore (Environment * theEnv, long long depth)
{
  QUERY_STACK *qptr;

  if (depth == 0)
    return InstanceQueryData (theEnv)->QueryCore;
  qptr = InstanceQueryData (theEnv)->QueryCoreStack;
  while (depth > 1)
    {
      qptr = qptr->nxt;
      depth--;
    }
  return qptr->core;
}

/**********************************************************
  NAME         : Dete_rmineQueryClasses
  DESCRIPTION  : CL_Builds a list of classes to be used in
                   instance queries - uses parse fo_rm.
  INPUTS       : 1) The parse class expression chain
                 2) The name of the function being executed
                 3) Caller's buffer for restriction count
                    (# of separate lists)
  RETURNS      : The query list, or NULL on errors
  SIDE EFFECTS : Memory allocated for list
                 Busy count incremented for all classes
  NOTES        : Each restriction is linked by nxt pointer,
                   multiple classes in a restriction are
                   linked by the chain pointer.
                 Rcnt caller's buffer is set to reflect the
                   total number of chains
                 Assumes classExp is not NULL and that each
                   restriction chain is te_rminated with
                   the QUERY_DELIMITER_SYMBOL "(QDS)"
 **********************************************************/
static QUERY_CLASS *
Dete_rmineQueryClasses (Environment * theEnv,
			Expression * classExp,
			const char *func, unsigned *rcnt)
{
  QUERY_CLASS *clist = NULL, *cnxt = NULL, *cchain = NULL, *tmp;
  bool new_list = false;
  UDFValue temp;
  Defclass *theClass;

  *rcnt = 0;
  while (classExp != NULL)
    {
      theClass = NULL;

      if (classExp->type == DEFCLASS_PTR)
	{
	  theClass = (Defclass *) classExp->value;
	}
      else if (CL_EvaluateExpression (theEnv, classExp, &temp))
	{
	  DeleteQueryClasses (theEnv, clist);
	  return NULL;
	}

      if ((theClass == NULL) &&
	  (temp.value ==
	   (void *) InstanceQueryData (theEnv)->QUERY_DELIMITER_SYMBOL))
	{
	  new_list = true;
	  (*rcnt)++;
	}
      else if ((tmp = Fo_rmChain (theEnv, func, theClass, &temp)) != NULL)
	{
	  if (clist == NULL)
	    clist = cnxt = cchain = tmp;
	  else if (new_list == true)
	    {
	      new_list = false;
	      cnxt->nxt = tmp;
	      cnxt = cchain = tmp;
	    }
	  else
	    cchain->chain = tmp;
	  while (cchain->chain != NULL)
	    cchain = cchain->chain;
	}
      else
	{
	  CL_SyntaxErrorMessage (theEnv,
				 "instance-set query class restrictions");
	  DeleteQueryClasses (theEnv, clist);
	  Set_EvaluationError (theEnv, true);
	  return NULL;
	}
      classExp = classExp->nextArg;
    }
  return (clist);
}

/*************************************************************
  NAME         : Fo_rmChain
  DESCRIPTION  : CL_Builds a list of classes to be used in
                   instance queries - uses parse fo_rm.
  INPUTS       : 1) Name of calling function for error msgs
                 2) Data object - must be a symbol or a
                      multifield value containing all symbols
                 The symbols must be names of existing classes
  RETURNS      : The query chain, or NULL on errors
  SIDE EFFECTS : Memory allocated for chain
                 Busy count incremented for all classes
  NOTES        : None
 *************************************************************/
static QUERY_CLASS *
Fo_rmChain (Environment * theEnv,
	    const char *func, Defclass * theClass, UDFValue * val)
{
  Defclass *cls;
  QUERY_CLASS *head, *bot, *tmp;
  size_t i;
  const char *className;
  Defmodule *currentModule;

  currentModule = CL_GetCurrentModule (theEnv);
  if (theClass != NULL)
    {
      CL_IncrementDefclassBusyCount (theEnv, theClass);
      head = get_struct (theEnv, query_class);
      head->cls = theClass;
      if (CL_DefclassInScope (theEnv, head->cls, currentModule))
	head->theModule = currentModule;
      else
	head->theModule = head->cls->header.whichModule->theModule;
      head->chain = NULL;
      head->nxt = NULL;
      return (head);
    }

  if (val->header->type == SYMBOL_TYPE)
    {
      /* ===============================================
         Allow instance-set query restrictions to have a
         module specifier as part of the class name,
         but search imported defclasses too if a
         module specifier is not given
         =============================================== */
      cls =
	CL_LookupDefclassByMdlOrScope (theEnv, val->lexemeValue->contents);
      if (cls == NULL)
	{
	  CL_ClassExistError (theEnv, func, val->lexemeValue->contents);
	  return NULL;
	}
      CL_IncrementDefclassBusyCount (theEnv, (Defclass *) cls);
      head = get_struct (theEnv, query_class);
      head->cls = cls;
      if (CL_DefclassInScope (theEnv, head->cls, currentModule))
	head->theModule = currentModule;
      else
	head->theModule = head->cls->header.whichModule->theModule;
      head->chain = NULL;
      head->nxt = NULL;
      return (head);
    }

  if (val->header->type == MULTIFIELD_TYPE)
    {
      head = bot = NULL;
      for (i = val->begin; i < (val->begin + val->range); i++)
	{
	  if (val->multifieldValue->contents[i].header->type == SYMBOL_TYPE)
	    {
	      className =
		val->multifieldValue->contents[i].lexemeValue->contents;
	      cls = CL_LookupDefclassByMdlOrScope (theEnv, className);
	      if (cls == NULL)
		{
		  CL_ClassExistError (theEnv, func, className);
		  DeleteQueryClasses (theEnv, head);
		  return NULL;
		}
	    }
	  else
	    {
	      DeleteQueryClasses (theEnv, head);
	      return NULL;
	    }
	  CL_IncrementDefclassBusyCount (theEnv, (Defclass *) cls);
	  tmp = get_struct (theEnv, query_class);
	  tmp->cls = cls;
	  if (CL_DefclassInScope (theEnv, tmp->cls, currentModule))
	    tmp->theModule = currentModule;
	  else
	    tmp->theModule = tmp->cls->header.whichModule->theModule;
	  tmp->chain = NULL;
	  tmp->nxt = NULL;
	  if (head == NULL)
	    head = tmp;
	  else
	    bot->chain = tmp;
	  bot = tmp;
	}
      return (head);
    }
  return NULL;
}

/******************************************************
  NAME         : DeleteQueryClasses
  DESCRIPTION  : Deletes a query class-list
  INPUTS       : The query list address
  RETURNS      : Nothing useful
  SIDE EFFECTS : Nodes deallocated
                 Busy count decremented for all classes
  NOTES        : None
 ******************************************************/
static void
DeleteQueryClasses (Environment * theEnv, QUERY_CLASS * qlist)
{
  QUERY_CLASS *tmp;

  while (qlist != NULL)
    {
      while (qlist->chain != NULL)
	{
	  tmp = qlist->chain;
	  qlist->chain = qlist->chain->chain;
	  CL_DecrementDefclassBusyCount (theEnv, (Defclass *) tmp->cls);
	  rtn_struct (theEnv, query_class, tmp);
	}
      tmp = qlist;
      qlist = qlist->nxt;
      CL_DecrementDefclassBusyCount (theEnv, (Defclass *) tmp->cls);
      rtn_struct (theEnv, query_class, tmp);
    }
}

/************************************************************
  NAME         : TestForFirstInChain
  DESCRIPTION  : Processes all classes in a restriction chain
                   until success or done
  INPUTS       : 1) The current chain
                 2) The index of the chain restriction
                     (e.g. the 4th query-variable)
  RETURNS      : True if query succeeds, false otherwise
  SIDE EFFECTS : Sets current restriction class
                 Instance variable values set
  NOTES        : None
 ************************************************************/
static bool
TestForFirstInChain (Environment * theEnv,
		     QUERY_CLASS * qchain, unsigned indx)
{
  QUERY_CLASS *qptr;
  int id;

  InstanceQueryData (theEnv)->AbortQuery = true;
  for (qptr = qchain; qptr != NULL; qptr = qptr->chain)
    {
      InstanceQueryData (theEnv)->AbortQuery = false;
      if ((id = CL_GetTraversalID (theEnv)) == -1)
	return false;
      if (TestForFirstInstanceInClass
	  (theEnv, qptr->theModule, id, qptr->cls, qchain, indx))
	{
	  CL_ReleaseTraversalID (theEnv);
	  return true;
	}
      CL_ReleaseTraversalID (theEnv);
      if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	  || (InstanceQueryData (theEnv)->AbortQuery == true))
	return false;
    }
  return false;
}

/*****************************************************************
  NAME         : TestForFirstInstanceInClass
  DESCRIPTION  : Processes all instances in a class and then
                   all subclasses of a class until success or done
  INPUTS       : 1) The module for which classes tested must be
                    in scope
                 2) Visitation traversal id
                 3) The class
                 4) The current class restriction chain
                 5) The index of the current restriction
  RETURNS      : True if query succeeds, false otherwise
  SIDE EFFECTS : Instance variable values set
  NOTES        : None
 *****************************************************************/
static bool
TestForFirstInstanceInClass (Environment * theEnv,
			     Defmodule * theModule,
			     int id,
			     Defclass * cls,
			     QUERY_CLASS * qchain, unsigned indx)
{
  unsigned long i;
  Instance *ins;
  UDFValue temp;
  GCBlock gcb;
  unsigned j;

  if (TestTraversalID (cls->traversalRecord, id))
    return false;
  SetTraversalID (cls->traversalRecord, id);
  if (CL_DefclassInScope (theEnv, cls, theModule) == false)
    return false;

  CL_GCBlockStart (theEnv, &gcb);

  ins = cls->instanceList;
  while (ins != NULL)
    {
      InstanceQueryData (theEnv)->QueryCore->solns[indx] = ins;
      if (qchain->nxt != NULL)
	{
	  ins->busy++;
	  if (TestForFirstInChain (theEnv, qchain->nxt, indx + 1) == true)
	    {
	      ins->busy--;
	      break;
	    }
	  ins->busy--;
	  if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	      || (InstanceQueryData (theEnv)->AbortQuery == true))
	    break;
	}
      else
	{
	  for (j = 0; j < indx; j++)
	    {
	      if (InstanceQueryData (theEnv)->QueryCore->solns[j]->garbage)
		{
		  ins = NULL;
		  goto endTest;
		}
	    }

	  ins->busy++;
	  CL_EvaluateExpression (theEnv,
				 InstanceQueryData (theEnv)->QueryCore->query,
				 &temp);
	  ins->busy--;
	  if (CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	    break;
	  if (temp.value != FalseSymbol (theEnv))
	    break;
	}

      CL_CleanCurrentGarbageFrame (theEnv, NULL);
      CL_CallPeriodicTasks (theEnv);

      ins = ins->nxtClass;
      while ((ins != NULL) ? (ins->garbage == 1) : false)
	ins = ins->nxtClass;
    }

endTest:

  CL_GCBlockEnd (theEnv, &gcb);
  CL_CallPeriodicTasks (theEnv);

  if (ins != NULL)
    return (((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	     || (InstanceQueryData (theEnv)->AbortQuery ==
		 true)) ? false : true);
  for (i = 0; i < cls->directSubclasses.classCount; i++)
    {
      if (TestForFirstInstanceInClass
	  (theEnv, theModule, id, cls->directSubclasses.classArray[i], qchain,
	   indx))
	return true;
      if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	  || (InstanceQueryData (theEnv)->AbortQuery == true))
	return false;
    }
  return false;
}

/************************************************************
  NAME         : TestEntireChain
  DESCRIPTION  : Processes all classes in a restriction chain
                   until done
  INPUTS       : 1) The current chain
                 2) The index of the chain restriction
                     (i.e. the 4th query-variable)
  RETURNS      : Nothing useful
  SIDE EFFECTS : Sets current restriction class
                 Query instance variables set
                 Solution sets stored in global list
  NOTES        : None
 ************************************************************/
static void
TestEntireChain (Environment * theEnv, QUERY_CLASS * qchain, unsigned indx)
{
  QUERY_CLASS *qptr;
  int id;

  InstanceQueryData (theEnv)->AbortQuery = true;
  for (qptr = qchain; qptr != NULL; qptr = qptr->chain)
    {
      InstanceQueryData (theEnv)->AbortQuery = false;
      if ((id = CL_GetTraversalID (theEnv)) == -1)
	return;
      TestEntireClass (theEnv, qptr->theModule, id, qptr->cls, qchain, indx);
      CL_ReleaseTraversalID (theEnv);
      if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	  || (InstanceQueryData (theEnv)->AbortQuery == true))
	return;
    }
}

/*****************************************************************
  NAME         : TestEntireClass
  DESCRIPTION  : Processes all instances in a class and then
                   all subclasses of a class until done
  INPUTS       : 1) The module for which classes tested must be
                    in scope
                 2) Visitation traversal id
                 3) The class
                 4) The current class restriction chain
                 5) The index of the current restriction
  RETURNS      : Nothing useful
  SIDE EFFECTS : Instance variable values set
                 Solution sets stored in global list
  NOTES        : None
 *****************************************************************/
static void
TestEntireClass (Environment * theEnv,
		 Defmodule * theModule,
		 int id, Defclass * cls, QUERY_CLASS * qchain, unsigned indx)
{
  unsigned long i;
  Instance *ins;
  UDFValue temp;
  GCBlock gcb;
  unsigned j;

  if (TestTraversalID (cls->traversalRecord, id))
    return;
  SetTraversalID (cls->traversalRecord, id);
  if (CL_DefclassInScope (theEnv, cls, theModule) == false)
    return;

  CL_GCBlockStart (theEnv, &gcb);

  ins = cls->instanceList;
  while (ins != NULL)
    {
      InstanceQueryData (theEnv)->QueryCore->solns[indx] = ins;
      if (qchain->nxt != NULL)
	{
	  ins->busy++;
	  TestEntireChain (theEnv, qchain->nxt, indx + 1);
	  ins->busy--;
	  if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	      || (InstanceQueryData (theEnv)->AbortQuery == true))
	    break;
	}
      else
	{
	  for (j = 0; j < indx; j++)
	    {
	      if (InstanceQueryData (theEnv)->QueryCore->solns[j]->garbage)
		{
		  goto endTest;
		}
	    }

	  ins->busy++;

	  CL_EvaluateExpression (theEnv,
				 InstanceQueryData (theEnv)->QueryCore->query,
				 &temp);

	  ins->busy--;
	  if (CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	    break;
	  if (temp.value != FalseSymbol (theEnv))
	    {
	      if (InstanceQueryData (theEnv)->QueryCore->action != NULL)
		{
		  ins->busy++;

		  CL_ReleaseUDFV (theEnv,
				  InstanceQueryData (theEnv)->QueryCore->
				  result);
		  CL_EvaluateExpression (theEnv,
					 InstanceQueryData (theEnv)->
					 QueryCore->action,
					 InstanceQueryData (theEnv)->
					 QueryCore->result);
		  CL_RetainUDFV (theEnv,
				 InstanceQueryData (theEnv)->QueryCore->
				 result);

		  ins->busy--;
		  if (ProcedureFunctionData (theEnv)->BreakFlag
		      || ProcedureFunctionData (theEnv)->ReturnFlag)
		    {
		      InstanceQueryData (theEnv)->AbortQuery = true;
		      break;
		    }
		  if (CL_EvaluationData (theEnv)->CL_HaltExecution == true)
		    break;
		}
	      else
		AddSolution (theEnv);
	    }
	}

      ins = ins->nxtClass;
      while ((ins != NULL) ? (ins->garbage == 1) : false)
	ins = ins->nxtClass;

      CL_CleanCurrentGarbageFrame (theEnv, NULL);
      CL_CallPeriodicTasks (theEnv);
    }

endTest:

  CL_GCBlockEnd (theEnv, &gcb);
  CL_CallPeriodicTasks (theEnv);

  if (ins != NULL)
    return;
  for (i = 0; i < cls->directSubclasses.classCount; i++)
    {
      TestEntireClass (theEnv, theModule, id,
		       cls->directSubclasses.classArray[i], qchain, indx);
      if ((CL_EvaluationData (theEnv)->CL_HaltExecution == true)
	  || (InstanceQueryData (theEnv)->AbortQuery == true))
	return;
    }
}

/***************************************************************************
  NAME         : AddSolution
  DESCRIPTION  : Adds the current instance set to a global list of
                   solutions
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Global list and count updated
  NOTES        : Solutions are stored as sequential arrays of Instance *
 ***************************************************************************/
static void
AddSolution (Environment * theEnv)
{
  QUERY_SOLN *new_soln;
  unsigned i;

  new_soln = (QUERY_SOLN *) CL_gm2 (theEnv, sizeof (QUERY_SOLN));
  new_soln->soln = (Instance **)
    CL_gm2 (theEnv,
	    (sizeof (Instance *) *
	     (InstanceQueryData (theEnv)->QueryCore->soln_size)));
  for (i = 0; i < InstanceQueryData (theEnv)->QueryCore->soln_size; i++)
    new_soln->soln[i] = InstanceQueryData (theEnv)->QueryCore->solns[i];
  new_soln->nxt = NULL;
  if (InstanceQueryData (theEnv)->QueryCore->soln_set == NULL)
    InstanceQueryData (theEnv)->QueryCore->soln_set = new_soln;
  else
    InstanceQueryData (theEnv)->QueryCore->soln_bottom->nxt = new_soln;
  InstanceQueryData (theEnv)->QueryCore->soln_bottom = new_soln;
  InstanceQueryData (theEnv)->QueryCore->soln_cnt++;
}

/***************************************************
  NAME         : PopQuerySoln
  DESCRIPTION  : Deallocates the topmost solution
                   set for an instance-set query
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Solution set deallocated
  NOTES        : Assumes QueryCore->soln_set != 0
 ***************************************************/
static void
PopQuerySoln (Environment * theEnv)
{
  InstanceQueryData (theEnv)->QueryCore->soln_bottom =
    InstanceQueryData (theEnv)->QueryCore->soln_set;
  InstanceQueryData (theEnv)->QueryCore->soln_set =
    InstanceQueryData (theEnv)->QueryCore->soln_set->nxt;
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->soln_bottom->soln,
	 (sizeof (Instance *) *
	  InstanceQueryData (theEnv)->QueryCore->soln_size));
  CL_rm (theEnv, InstanceQueryData (theEnv)->QueryCore->soln_bottom,
	 sizeof (QUERY_SOLN));
}

#endif
