   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  07/02/18             */
   /*                                                     */
   /*                  DEFINSTANCES MODULE                */
   /*******************************************************/

/*************************************************************/
/* Purpose: Kernel definstances interface commands           */
/*              and routines                                 */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Contributing Programmer(s):                               */
/*                                                           */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable exp to theExp         */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Converted INSTANCE_PATTERN_MATCHING to         */
/*            DEFRULE_CONSTRUCT.                             */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Removed conditional code for unsupported       */
/*            compilers/operating systems (IBM_MCW,          */
/*            MAC_MCW, and IBM_TBC).                         */
/*                                                           */
/*            CL_GetConstructNameAndComment API change.         */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*            Changed find construct functionality so that   */
/*            imported modules are search when locating a    */
/*            named construct.                               */
/*                                                           */
/*      6.40: Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*            Removed initial-object support.                */
/*                                                           */
/*            Pretty print functions accept optional logical */
/*            name argument.                                 */
/*                                                           */
/*************************************************************/

/* =========================================
   *****************************************
               EXTERNAL DEFINITIONS
   =========================================
   ***************************************** */
#include "setup.h"

#if DEFINSTANCES_CONSTRUCT

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
#include "bload.h"
#include "dfinsbin.h"
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
#include "dfinscmp.h"
#endif

#include "argacces.h"
#include "classcom.h"
#include "classfun.h"
#include "cstrccom.h"
#include "cstrcpsr.h"
#include "constant.h"
#include "constrct.h"
#include "envrnmnt.h"
#include "evaluatn.h"
#include "extnfunc.h"
#include "insfun.h"
#include "inspsr.h"
#include "memalloc.h"
#include "modulpsr.h"
#include "modulutl.h"
#include "pprint.h"
#include "prntutil.h"
#include "router.h"
#include "scanner.h"
#include "symbol.h"
#include "utility.h"

#include "defins.h"

/* =========================================
   *****************************************
                   CONSTANTS
   =========================================
   ***************************************** */
#define ACTIVE_RLN "active"

/* =========================================
   *****************************************
      INTERNALLY VISIBLE FUNCTION HEADERS
   =========================================
   ***************************************** */

#if (! BLOAD_ONLY) && (! RUN_TIME)
static bool ParseDefinstances (Environment *, const char *);
static CLIPSLexeme *Parse_DefinstancesName (Environment *, const char *,
					    bool *);
static void RemoveDefinstances (Environment *, Definstances *);
static void CL_SaveDefinstances (Environment *, Defmodule *, const char *,
				 void *);
#endif

#if ! RUN_TIME
static void *AllocateModule (Environment *);
static void ReturnModule (Environment *, void *);
static bool CL_ClearDefinstancesReady (Environment *, void *);
static void CheckDefinstancesBusy (Environment *, ConstructHeader *, void *);
static void DestroyDefinstancesAction (Environment *, ConstructHeader *,
				       void *);
#else
static void CL_RuntimeDefinstancesAction (Environment *, ConstructHeader *,
					  void *);
#endif

static void CL_ResetDefinstances (Environment *, void *);
static void CL_ResetDefinstancesAction (Environment *, ConstructHeader *,
					void *);
static void DeallocateDefinstancesData (Environment *);

/* =========================================
   *****************************************
          EXTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***************************************************
  NAME         : CL_SetupDefinstances
  DESCRIPTION  : Adds the definstance support routines
                   to the Kernel
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Appropriate function lists modified
  NOTES        : None
 ***************************************************/
void
CL_SetupDefinstances (Environment * theEnv)
{
  CL_AllocateEnvironmentData (theEnv, DEFINSTANCES_DATA,
			      sizeof (struct definstancesData),
			      DeallocateDefinstancesData);

  DefinstancesData (theEnv)->CL_DefinstancesModuleIndex =
    CL_RegisterModuleItem (theEnv, "definstances",
#if (! RUN_TIME)
			   AllocateModule, ReturnModule,
#else
			   NULL, NULL,
#endif
#if BLOAD_AND_BSAVE || BLOAD || BLOAD_ONLY
			   CL_Bload_DefinstancesModuleRef,
#else
			   NULL,
#endif
#if CONSTRUCT_COMPILER && (! RUN_TIME)
			   CL_DefinstancesCModuleReference,
#else
			   NULL,
#endif
			   (CL_FindConstructFunction *)
			   CL_FindDefinstancesInModule);

  DefinstancesData (theEnv)->DefinstancesConstruct =
    CL_AddConstruct (theEnv, "definstances", "definstances",
#if (! BLOAD_ONLY) && (! RUN_TIME)
		     ParseDefinstances,
#else
		     NULL,
#endif
		     (CL_FindConstructFunction *) CL_FindDefinstances,
		     CL_GetConstructNamePointer, CL_GetConstructPPFo_rm,
		     CL_GetConstructModuleItem,
		     (GetNextConstructFunction *) CL_GetNextDefinstances,
		     CL_SetNextConstruct,
		     (IsConstructDeletableFunction *)
		     CL_DefinstancesIsDeletable,
		     (DeleteConstructFunction *) CL_Undefinstances,
#if (! BLOAD_ONLY) && (! RUN_TIME)
		     (FreeConstructFunction *) RemoveDefinstances
#else
		     NULL
#endif
    );

#if ! RUN_TIME
  CL_Add_ClearReadyFunction (theEnv, "definstances",
			     CL_ClearDefinstancesReady, 0, NULL);

#if ! BLOAD_ONLY
  CL_AddUDF (theEnv, "undefinstances", "v", 1, 1, "y",
	     CL_UndefinstancesCommand, "CL_UndefinstancesCommand", NULL);
  CL_Add_SaveFunction (theEnv, "definstances", CL_SaveDefinstances, 0, NULL);
#endif

#if DEBUGGING_FUNCTIONS
  CL_AddUDF (theEnv, "ppdefinstances", "vs", 1, 2, ";y;ldsyn",
	     CL_PPDefinstancesCommand, "CL_PPDefinstancesCommand", NULL);
  CL_AddUDF (theEnv, "list-definstances", "v", 0, 1, "y",
	     CL_ListDefinstancesCommand, "CL_ListDefinstancesCommand", NULL);
#endif

  CL_AddUDF (theEnv, "get-definstances-list", "m", 0, 1, "y",
	     CL_GetDefinstancesListFunction, "CL_GetDefinstancesListFunction",
	     NULL);
  CL_AddUDF (theEnv, "definstances-module", "y", 1, 1, "y",
	     Get_DefinstancesModuleCommand, "Get_DefinstancesModuleCommand",
	     NULL);

#endif
  CL_Add_ResetFunction (theEnv, "definstances", CL_ResetDefinstances, 0,
			NULL);

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
  CL_SetupDefinstances_Bload (theEnv);
#endif

#if CONSTRUCT_COMPILER && (! RUN_TIME)
  CL_SetupDefinstancesCompiler (theEnv);
#endif
}

/*******************************************************/
/* DeallocateDefinstancesData: Deallocates environment */
/*    data for the definstances construct.             */
/*******************************************************/
static void
DeallocateDefinstancesData (Environment * theEnv)
{
#if ! RUN_TIME
  struct definstancesModule *theModuleItem;
  Defmodule *theModule;

#if BLOAD || BLOAD_AND_BSAVE
  if (CL_Bloaded (theEnv))
    return;
#endif

  CL_DoForAllConstructs (theEnv, DestroyDefinstancesAction,
			 DefinstancesData (theEnv)->
			 CL_DefinstancesModuleIndex, false, NULL);

  for (theModule = CL_GetNextDefmodule (theEnv, NULL);
       theModule != NULL; theModule = CL_GetNextDefmodule (theEnv, theModule))
    {
      theModuleItem = (struct definstancesModule *)
	CL_GetModuleItem (theEnv, theModule,
			  DefinstancesData (theEnv)->
			  CL_DefinstancesModuleIndex);
      rtn_struct (theEnv, definstancesModule, theModuleItem);
    }
#else
#if MAC_XCD
#pragma unused(theEnv)
#endif
#endif
}

#if ! RUN_TIME
/*****************************************************/
/* DestroyDefinstancesAction: Action used to remove  */
/*   definstances as a result of CL_DestroyEnvironment. */
/*****************************************************/
static void
DestroyDefinstancesAction (Environment * theEnv,
			   ConstructHeader * theConstruct, void *buffer)
{
#if MAC_XCD
#pragma unused(buffer)
#endif
#if (! BLOAD_ONLY) && (! RUN_TIME)
  struct definstances *theDefinstances = (struct definstances *) theConstruct;

  if (theDefinstances == NULL)
    return;

  CL_ReturnPackedExpression (theEnv, theDefinstances->mkinstance);

  CL_DestroyConstructHeader (theEnv, &theDefinstances->header);

  rtn_struct (theEnv, definstances, theDefinstances);
#else
#if MAC_XCD
#pragma unused(theConstruct,theEnv)
#endif
#endif
}
#endif

#if RUN_TIME

/***************************************************/
/* CL_RuntimeDefinstancesAction: Action to be applied */
/*   to each definstances construct when a runtime */
/*   initialization occurs.                        */
/***************************************************/
static void
CL_RuntimeDefinstancesAction (Environment * theEnv,
			      ConstructHeader * theConstruct, void *buffer)
{
#if MAC_XCD
#pragma unused(buffer)
#endif
  Definstances *theDefinstances = (Definstances *) theConstruct;

  theDefinstances->header.env = theEnv;
}

/**********************************/
/* Definstances_RunTimeInitialize: */
/**********************************/
void
Definstances_RunTimeInitialize (Environment * theEnv)
{
  CL_DoForAllConstructs (theEnv, CL_RuntimeDefinstancesAction,
			 DefinstancesData (theEnv)->
			 CL_DefinstancesModuleIndex, true, NULL);
}

#endif

/***********************************************************
  NAME         : CL_GetNextDefinstances
  DESCRIPTION  : Finds first or next definstances
  INPUTS       : The address of the current definstances
  RETURNS      : The address of the next definstances
                   (NULL if none)
  SIDE EFFECTS : None
  NOTES        : If ptr == NULL, the first definstances
                    is returned.
 ***********************************************************/
Definstances *
CL_GetNextDefinstances (Environment * theEnv, Definstances * theDefinstances)
{
  return (Definstances *) CL_GetNextConstructItem (theEnv,
						   &theDefinstances->header,
						   DefinstancesData (theEnv)->
						   CL_DefinstancesModuleIndex);
}

/***************************************************
  NAME         : CL_FindDefinstances
  DESCRIPTION  : Looks up a definstance construct
                   by name-string
  INPUTS       : The symbolic name
  RETURNS      : The definstance address, or NULL
                    if not found
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Definstances *
CL_FindDefinstances (Environment * theEnv, const char *name)
{
  return (Definstances *) CL_FindNamedConstructInModuleOrImports (theEnv,
								  name,
								  DefinstancesData
								  (theEnv)->
								  DefinstancesConstruct);
}

/***************************************************
  NAME         : CL_FindDefinstancesInModule
  DESCRIPTION  : Looks up a definstance construct
                   by name-string
  INPUTS       : The symbolic name
  RETURNS      : The definstance address, or NULL
                    if not found
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Definstances *
CL_FindDefinstancesInModule (Environment * theEnv, const char *name)
{
  return (Definstances *) CL_FindNamedConstructInModule (theEnv, name,
							 DefinstancesData
							 (theEnv)->
							 DefinstancesConstruct);
}

/***************************************************
  NAME         : CL_DefinstancesIsDeletable
  DESCRIPTION  : Dete_rmines if a definstances
                   can be deleted
  INPUTS       : Address of the definstances
  RETURNS      : True if deletable, false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
bool
CL_DefinstancesIsDeletable (Definstances * theDefinstances)
{
  Environment *theEnv = theDefinstances->header.env;

  if (!CL_ConstructsDeletable (theEnv))
    {
      return false;
    }

  return (theDefinstances->busy == 0) ? true : false;
}

/***********************************************************
  NAME         : CL_UndefinstancesCommand
  DESCRIPTION  : Removes a definstance
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstance deallocated
  NOTES        : H/L Syntax : (undefinstances <name> | *)
 ***********************************************************/
void
CL_UndefinstancesCommand (Environment * theEnv,
			  UDFContext * context, UDFValue * returnValue)
{
  CL_UndefconstructCommand (context, "undefinstances",
			    DefinstancesData (theEnv)->DefinstancesConstruct);
}

/*****************************************************************
  NAME         : Get_DefinstancesModuleCommand
  DESCRIPTION  : Dete_rmines to which module a definstances belongs
  INPUTS       : None
  RETURNS      : The symbolic name of the module
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (definstances-module <defins-name>)
 *****************************************************************/
void
Get_DefinstancesModuleCommand (Environment * theEnv,
			       UDFContext * context, UDFValue * returnValue)
{
  returnValue->value =
    CL_GetConstructModuleCommand (context, "definstances-module",
				  DefinstancesData (theEnv)->
				  DefinstancesConstruct);
}

/***********************************************************
  NAME         : CL_Undefinstances
  DESCRIPTION  : Removes a definstance
  INPUTS       : Address of definstances to remove
  RETURNS      : True if successful,
                 false otherwise
  SIDE EFFECTS : Definstance deallocated
  NOTES        : None
 ***********************************************************/
bool
CL_Undefinstances (Definstances * theDefinstances, Environment * allEnv)
{
  Environment *theEnv;

  if (theDefinstances == NULL)
    {
      theEnv = allEnv;
      return CL_Undefconstruct (theEnv, NULL,
				DefinstancesData (theEnv)->
				DefinstancesConstruct);
    }
  else
    {
      theEnv = theDefinstances->header.env;
      return CL_Undefconstruct (theEnv, &theDefinstances->header,
				DefinstancesData (theEnv)->
				DefinstancesConstruct);
    }
}

#if DEBUGGING_FUNCTIONS

/***************************************************************
  NAME         : CL_PPDefinstancesCommand
  DESCRIPTION  : Prints out the pretty-print fo_rm of a definstance
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax : (ppdefinstances <name>)
 ***************************************************************/
void
CL_PPDefinstancesCommand (Environment * theEnv,
			  UDFContext * context, UDFValue * returnValue)
{
  CL_PPConstructCommand (context, "ppdefinstances",
			 DefinstancesData (theEnv)->DefinstancesConstruct,
			 returnValue);
}

/***************************************************
  NAME         : CL_ListDefinstancesCommand
  DESCRIPTION  : Displays all definstances names
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstances name sprinted
  NOTES        : H/L Interface
 ***************************************************/
void
CL_ListDefinstancesCommand (Environment * theEnv,
			    UDFContext * context, UDFValue * returnValue)
{
  CL_ListConstructCommand (context,
			   DefinstancesData (theEnv)->DefinstancesConstruct);
}

/***************************************************
  NAME         : CL_ListDefinstances
  DESCRIPTION  : Displays all definstances names
  INPUTS       : 1) The logical name of the output
                 2) The module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Definstances names printed
  NOTES        : C Interface
 ***************************************************/
void
CL_ListDefinstances (Environment * theEnv,
		     const char *logicalName, Defmodule * theModule)
{
  CL_ListConstruct (theEnv, DefinstancesData (theEnv)->DefinstancesConstruct,
		    logicalName, theModule);
}

#endif

/****************************************************************
  NAME         : CL_GetDefinstancesListFunction
  DESCRIPTION  : Groups all definstances names into
                 a multifield list
  INPUTS       : A data object buffer to hold
                 the multifield result
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : H/L Syntax: (get-definstances-list [<module>])
 ****************************************************************/
void
CL_GetDefinstancesListFunction (Environment * theEnv,
				UDFContext * context, UDFValue * returnValue)
{
  CL_GetConstructListFunction (context, returnValue,
			       DefinstancesData (theEnv)->
			       DefinstancesConstruct);
}

/***************************************************************
  NAME         : CL_GetDefinstancesList
  DESCRIPTION  : Groups all definstances names into
                 a multifield list
  INPUTS       : 1) A data object buffer to hold
                    the multifield result
                 2) The module from which to obtain definstances
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : External C access
 ***************************************************************/
void
CL_GetDefinstancesList (Environment * theEnv,
			CLIPSValue * returnValue, Defmodule * theModule)
{
  UDFValue result;

  CL_GetConstructList (theEnv, &result,
		       DefinstancesData (theEnv)->DefinstancesConstruct,
		       theModule);
  CL_No_rmalizeMultifield (theEnv, &result);
  returnValue->value = result.value;
}

/* =========================================
   *****************************************
          INTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

#if (! BLOAD_ONLY) && (! RUN_TIME)

/*********************************************************************
  NAME         : ParseDefinstances
  DESCRIPTION  : Parses and allocates a definstances construct
  INPUTS       : The logical name of the input source
  RETURNS      : False if no errors, true otherwise
  SIDE EFFECTS : Definstances parsed and created
  NOTES        : H/L Syntax :

                 (definstances  <name> [active] [<comment>]
                    <instance-definition>+)

                 <instance-definition> ::=
                    (<instance-name> of <class-name> <slot-override>*)

                 <slot-override> ::= (<slot-name> <value-expression>*)
 *********************************************************************/
static bool
ParseDefinstances (Environment * theEnv, const char *readSource)
{
  CLIPSLexeme *dname;
  struct functionDefinition *mkinsfcall;
  Expression *mkinstance, *mkbot = NULL;
  Definstances *dobj;
  bool active;

  CL_SetPPBufferStatus (theEnv, true);
  CL_FlushPPBuffer (theEnv);
  CL_SetIndentDepth (theEnv, 3);
  CL_SavePPBuffer (theEnv, "(definstances ");

#if BLOAD || BLOAD_AND_BSAVE
  if ((CL_Bloaded (theEnv)) && (!ConstructData (theEnv)->CL_CheckSyntaxMode))
    {
      Cannot_LoadWith_BloadMessage (theEnv, "definstances");
      return true;
    }
#endif
  dname = Parse_DefinstancesName (theEnv, readSource, &active);
  if (dname == NULL)
    return true;

  dobj = get_struct (theEnv, definstances);
  CL_InitializeConstructHeader (theEnv, "definstances", DEFINSTANCES,
				&dobj->header, dname);
  dobj->busy = 0;
  dobj->mkinstance = NULL;
#if DEFRULE_CONSTRUCT
  if (active)
    mkinsfcall = CL_FindFunction (theEnv, "active-make-instance");
  else
    mkinsfcall = CL_FindFunction (theEnv, "make-instance");
#else
  mkinsfcall = CL_FindFunction (theEnv, "make-instance");
#endif
  while (DefclassData (theEnv)->ObjectParseToken.tknType ==
	 LEFT_PARENTHESIS_TOKEN)
    {
      mkinstance = CL_GenConstant (theEnv, UNKNOWN_VALUE, mkinsfcall);
      mkinstance =
	CL_ParseInitializeInstance (theEnv, mkinstance, readSource);
      if (mkinstance == NULL)
	{
	  CL_ReturnExpression (theEnv, dobj->mkinstance);
	  rtn_struct (theEnv, definstances, dobj);
	  return true;
	}
      if (CL_ExpressionContainsVariables (mkinstance, false) == true)
	{
	  CL_LocalVariableErrorMessage (theEnv, "definstances");
	  CL_ReturnExpression (theEnv, mkinstance);
	  CL_ReturnExpression (theEnv, dobj->mkinstance);
	  rtn_struct (theEnv, definstances, dobj);
	  return true;
	}
      if (mkbot == NULL)
	dobj->mkinstance = mkinstance;
      else
	GetNextArgument (mkbot) = mkinstance;
      mkbot = mkinstance;
      CL_GetToken (theEnv, readSource,
		   &DefclassData (theEnv)->ObjectParseToken);
      CL_PPBackup (theEnv);
      CL_PPCRAndIndent (theEnv);
      CL_SavePPBuffer (theEnv,
		       DefclassData (theEnv)->ObjectParseToken.printFo_rm);
    }

  if (DefclassData (theEnv)->ObjectParseToken.tknType !=
      RIGHT_PARENTHESIS_TOKEN)
    {
      CL_ReturnExpression (theEnv, dobj->mkinstance);
      rtn_struct (theEnv, definstances, dobj);
      CL_SyntaxErrorMessage (theEnv, "definstances");
      return true;
    }
  else
    {
      if (ConstructData (theEnv)->CL_CheckSyntaxMode)
	{
	  CL_ReturnExpression (theEnv, dobj->mkinstance);
	  rtn_struct (theEnv, definstances, dobj);
	  return false;
	}
#if DEBUGGING_FUNCTIONS
      if (CL_GetConserveMemory (theEnv) == false)
	{
	  if (dobj->mkinstance != NULL)
	    CL_PPBackup (theEnv);
	  CL_PPBackup (theEnv);
	  CL_SavePPBuffer (theEnv, ")\n");
	  SetCL_DefinstancesPPFo_rm (theEnv, dobj, CL_CopyPPBuffer (theEnv));
	}
#endif
      mkinstance = dobj->mkinstance;
      dobj->mkinstance = CL_PackExpression (theEnv, mkinstance);
      CL_ReturnExpression (theEnv, mkinstance);
      IncrementLexemeCount (Get_DefinstancesNamePointer (theEnv, dobj));
      CL_ExpressionInstall (theEnv, dobj->mkinstance);
    }

  CL_AddConstructToModule (&dobj->header);
  return false;
}

/*************************************************************
  NAME         : Parse_DefinstancesName
  DESCRIPTION  : Parses definstance name and optional comment
                 and optional "active" keyword
  INPUTS       : 1) The logical name of the input source
                 2) Buffer to hold flag indicating if
                    definstances should cause pattern-matching
                    to occur during slot-overrides
  RETURNS      : Address of name symbol, or
                   NULL if there was an error
  SIDE EFFECTS : Token after name or comment is scanned
  NOTES        : Assumes "(definstances" has already
                   been scanned.
 *************************************************************/
static CLIPSLexeme *
Parse_DefinstancesName (Environment * theEnv,
			const char *readSource, bool *active)
{
  CLIPSLexeme *dname;

  *active = false;
  dname =
    CL_GetConstructNameAndComment (theEnv, readSource,
				   &DefclassData (theEnv)->ObjectParseToken,
				   "definstances",
				   (CL_FindConstructFunction *)
				   CL_FindDefinstancesInModule,
				   (DeleteConstructFunction *)
				   CL_Undefinstances, "@", true, false, true,
				   false);
  if (dname == NULL)
    return NULL;

#if DEFRULE_CONSTRUCT
  if ((DefclassData (theEnv)->ObjectParseToken.tknType !=
       SYMBOL_TOKEN) ? false : (strcmp (DefclassData (theEnv)->
					ObjectParseToken.lexemeValue->
					contents, ACTIVE_RLN) == 0))
    {
      CL_PPBackup (theEnv);
      CL_PPBackup (theEnv);
      CL_SavePPBuffer (theEnv, " ");
      CL_SavePPBuffer (theEnv,
		       DefclassData (theEnv)->ObjectParseToken.printFo_rm);
      CL_PPCRAndIndent (theEnv);
      CL_GetToken (theEnv, readSource,
		   &DefclassData (theEnv)->ObjectParseToken);
      *active = true;
    }
#endif
  if (DefclassData (theEnv)->ObjectParseToken.tknType == STRING_TOKEN)
    {
      CL_PPBackup (theEnv);
      CL_PPBackup (theEnv);
      CL_SavePPBuffer (theEnv, " ");
      CL_SavePPBuffer (theEnv,
		       DefclassData (theEnv)->ObjectParseToken.printFo_rm);
      CL_PPCRAndIndent (theEnv);
      CL_GetToken (theEnv, readSource,
		   &DefclassData (theEnv)->ObjectParseToken);
    }
  return (dname);
}

/**************************************************************
  NAME         : RemoveDefinstances
  DESCRIPTION  : Deallocates and removes a definstance construct
  INPUTS       : The definstance address
  RETURNS      : Nothing useful
  SIDE EFFECTS : Existing definstance construct deleted
  NOTES        : Assumes busy count of definstance is 0
 **************************************************************/
static void
RemoveDefinstances (Environment * theEnv, Definstances * theDefinstances)
{
  CL_ReleaseLexeme (theEnv, theDefinstances->header.name);
  CL_ExpressionDeinstall (theEnv, theDefinstances->mkinstance);
  CL_ReturnPackedExpression (theEnv, theDefinstances->mkinstance);
  SetCL_DefinstancesPPFo_rm (theEnv, theDefinstances, NULL);
  CL_ClearUserDataList (theEnv, theDefinstances->header.usrData);
  rtn_struct (theEnv, definstances, theDefinstances);
}

/***************************************************
  NAME         : CL_SaveDefinstances
  DESCRIPTION  : Prints pretty print fo_rm of
                   definstances to specified output
  INPUTS       : The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
static void
CL_SaveDefinstances (Environment * theEnv,
		     Defmodule * theModule,
		     const char *logName, void *context)
{
  CL_SaveConstruct (theEnv, theModule, logName,
		    DefinstancesData (theEnv)->DefinstancesConstruct);
}

#endif

#if ! RUN_TIME

/*****************************************************
  NAME         : AllocateModule
  DESCRIPTION  : Creates and initializes a
                 list of definstances for a new module
  INPUTS       : None
  RETURNS      : The new definstances module
  SIDE EFFECTS : Definstances module created
  NOTES        : None
 *****************************************************/
static void *
AllocateModule (Environment * theEnv)
{
  return (void *) get_struct (theEnv, definstancesModule);
}

/***************************************************
  NAME         : ReturnModule
  DESCRIPTION  : Removes a definstances module and
                 all associated definstances
  INPUTS       : The definstances module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Module and definstances deleted
  NOTES        : None
 ***************************************************/
static void
ReturnModule (Environment * theEnv, void *theItem)
{
#if (! BLOAD_ONLY)
  CL_FreeConstructHeaderModule (theEnv,
				(struct defmoduleItemHeader *) theItem,
				DefinstancesData (theEnv)->
				DefinstancesConstruct);
#endif
  rtn_struct (theEnv, definstancesModule, theItem);
}

/***************************************************
  NAME         : CL_ClearDefinstancesReady
  DESCRIPTION  : Dete_rmines if it is safe to
                 remove all definstances
                 Assumes *all* constructs will be
                 deleted
  INPUTS       : None
  RETURNS      : True if all definstances can
                 be deleted, false otherwise
  SIDE EFFECTS : None
  NOTES        : Used by (clear) and (bload)
 ***************************************************/
static bool
CL_ClearDefinstancesReady (Environment * theEnv, void *context)
{
  bool flagBuffer = true;

  CL_DoForAllConstructs (theEnv, CheckDefinstancesBusy,
			 DefinstancesData (theEnv)->
			 CL_DefinstancesModuleIndex, false, &flagBuffer);
  return (flagBuffer);
}

/***************************************************
  NAME         : CheckDefinstancesBusy
  DESCRIPTION  : Dete_rmines if a definstances is
                 in use or not
  INPUTS       : 1) The definstances
                 2) A buffer to set to 0 if the
                    the definstances is busy
  RETURNS      : Nothing useful
  SIDE EFFECTS : Buffer set to 0 if definstances
                 busy
  NOTES        : The flag buffer is not modified
                 if definstances is not busy
                 (assumed to be initialized to 1)
 ***************************************************/
static void
CheckDefinstancesBusy (Environment * theEnv,
		       ConstructHeader * theDefinstances, void *userBuffer)
{
#if MAC_XCD
#pragma unused(theEnv)
#endif

  if (((Definstances *) theDefinstances)->busy > 0)
    {
      *((bool *) userBuffer) = false;
    }
}

#endif

/***************************************************
  NAME         : CL_ResetDefinstances
  DESCRIPTION  : Calls CL_EvaluateExpression for each of
                   the make-instance calls in all
                   of the definstances constructs
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : All instances in the definstances
                   are evaluated (and created if
                   there are no errors)
                 Any previously existing instances
                 are deleted first.
  NOTES        : None
 ***************************************************/
static void
CL_ResetDefinstances (Environment * theEnv, void *context)
{
  CL_DoForAllConstructs (theEnv, CL_ResetDefinstancesAction,
			 DefinstancesData (theEnv)->
			 CL_DefinstancesModuleIndex, true, NULL);
}

/***************************************************
  NAME         : CL_ResetDefinstancesAction
  DESCRIPTION  : Perfo_rms all the make-instance
                 calls in a definstances
  INPUTS       : 1) The definstances
                 2) User data buffer (ignored)
  RETURNS      : Nothing useful
  SIDE EFFECTS : CL_Instances created
  NOTES        : None
 ***************************************************/
static void
CL_ResetDefinstancesAction (Environment * theEnv,
			    ConstructHeader * vDefinstances, void *userBuffer)
{
#if MAC_XCD
#pragma unused(userBuffer)
#endif
  Definstances *theDefinstances = (Definstances *) vDefinstances;
  Expression *theExp;
  UDFValue temp;

  CL_SaveCurrentModule (theEnv);
  CL_SetCurrentModule (theEnv, vDefinstances->whichModule->theModule);
  theDefinstances->busy++;
  for (theExp = theDefinstances->mkinstance;
       theExp != NULL; theExp = GetNextArgument (theExp))
    {
      CL_EvaluateExpression (theEnv, theExp, &temp);
      if (CL_EvaluationData (theEnv)->CL_HaltExecution ||
	  (temp.value == FalseSymbol (theEnv)))
	{
	  CL_RestoreCurrentModule (theEnv);
	  theDefinstances->busy--;
	  return;
	}
    }
  theDefinstances->busy--;
  CL_RestoreCurrentModule (theEnv);
}

/*##################################*/
/* Additional Environment Functions */
/*##################################*/

const char *
CL_DefinstancesName (Definstances * theDefinstances)
{
  return CL_GetConstructNameString (&theDefinstances->header);
}

const char *
CL_DefinstancesPPFo_rm (Definstances * theDefinstances)
{
  return CL_GetConstructPPFo_rm (&theDefinstances->header);
}

void
SetCL_DefinstancesPPFo_rm (Environment * theEnv,
			   Definstances * theDefinstances,
			   const char *thePPFo_rm)
{
  SetConstructPPFo_rm (theEnv, &theDefinstances->header, thePPFo_rm);
}

const char *
CL_DefinstancesModule (Definstances * theDefinstances)
{
  return CL_GetConstructModuleName (&theDefinstances->header);
}

CLIPSLexeme *
Get_DefinstancesNamePointer (Environment * theEnv,
			     Definstances * theDefinstances)
{
  return CL_GetConstructNamePointer (&theDefinstances->header);
}

const char *
CL_DefinstancesModuleName (Environment * theEnv,
			   Definstances * theDefinstances)
{
  return CL_GetConstructModuleName (&theDefinstances->header);
}

#endif
